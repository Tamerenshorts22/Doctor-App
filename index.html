<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Doctor Consult Orchestrator (UI Skeleton • v1.4 Count Enforcement + Collapsible Q&A)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ===== Minimal, clean styling (no framework) ===== -->
  <style>
    :root{
      --bg:#0f1115;
      --panel:#151922;
      --panel-2:#111521;
      --text:#e8eaf1;
      --muted:#9aa3b2;
      --accent:#3b82f6;     /* active */
      --accent-2:#22c55e;   /* success */
      --border:#263042;
      --danger:#ef4444;
      --warn:#f59e0b;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg);
      color:var(--text);
      line-height:1.45;
    }

    /* Utility */
    .hidden{display:none !important;}

    /* ===== Top bar (centered) ===== */
    .topbar{
      position:sticky; top:0; z-index:10;
      background:linear-gradient(180deg, #151922, #121725);
      border-bottom:1px solid var(--border);
      padding:18px 16px;
      box-shadow:0 2px 18px rgba(0,0,0,0.25);
    }
    .tb-grid{
      display:grid;
      grid-template-columns: 1fr minmax(0, 760px) auto;
      align-items:center;
      gap:12px;
    }
    .tb-center{ display:flex; flex-direction:column; align-items:center; text-align:center; }
    .topbar h1{font-size:24px; margin:0 0 6px 0; font-weight:800; letter-spacing:.2px}
    .tb-right{ display:flex; gap:8px; align-items:center; justify-content:flex-end; }
    .status{ font-size:12px; color:var(--muted); padding:4px 8px; border:1px dashed var(--border); border-radius:8px; }

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px; padding:8px 12px; border-radius:10px;
      background:#1b2230; border:1px solid var(--border); color:var(--text);
      cursor:pointer; user-select:none; transition:transform .02s ease-in-out, opacity .2s;
    }
    .btn[disabled]{opacity:.5; cursor:not-allowed}
    .btn:hover:not([disabled]){transform:translateY(-1px)}
    .btn-clear{background:#161b28}
    .btn-copy{background:#141c2a}
    .btn-warn{background:#231a0e; border-color:#6b4b16}
    .btn-accept{background:#132016; border-color:#214d29}

    .pill{ display:inline-block; padding:4px 8px; border-radius:999px; background:#13192a; border:1px solid var(--border); color:#9fb2d8; font-size:12px; }
    .pill-kpi{ display:inline-block; padding:2px 8px; border-radius:999px; background:#101626; border:1px solid var(--border); color:#c8d3eb; font-size:11px; }
    .muted{color:var(--muted)}

    /* ===== 4-column main grid ===== */
    .container{ padding:16px; display:grid; grid-template-columns: 1fr 1fr  1fr 1fr; gap:16px; }
    @media (max-width:1360px){ .container{ grid-template-columns: 1fr 1fr; } }
    @media (max-width:900px){ .container{ grid-template-columns: 1fr; } }

    .card{
      position:relative;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
      box-shadow:0 0 0 1px rgba(255,255,255,0.02) inset, 0 2px 18px rgba(0,0,0,0.25);
    }
    .card h2{font-size:14px; margin:0 0 8px 0; font-weight:700; color:#e6ebff}

    /* === ACTIVE COLUMN (single-selection) === */
    .card.is-active{
      border-color: var(--accent);
      outline: 2px solid rgba(59,130,246,0.6);
      outline-offset: 2px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.05) inset,
                  0 8px 24px rgba(0,0,0,0.35);
    }

    .help{font-size:12px; color:var(--muted); margin-bottom:8px}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    textarea, input{
      width:100%; background:var(--panel-2); color:var(--text);
      border:1px solid var(--border); border-radius:10px;
      padding:10px 12px; font-size:14px; outline:none;
      transition:border-color .15s ease;
    }
    textarea{min-height:180px; resize:vertical}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .placeholder{ padding:10px 12px; border-radius:10px; background:#101626; border:1px dashed var(--border); color:#9fb2d8; font-size:13px; }
    .section-title{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; }
    .col-title{font-weight:700; letter-spacing:.2px}
    .stack-8 > * + *{margin-top:8px}
    .stack-12 > * + *{margin-top:12px}
    .stack-16 > * + *{margin-top:16px}
    .stack-24 > * + *{margin-top:24px}
    .divider{height:1px; background:var(--border); margin:12px 0}
    .note{ white-space:pre-wrap; background:#0f1524; border:1px solid var(--border); border-radius:10px; padding:12px; min-height:120px; color:#dbe7ff; font-size:14px; }
    .grid-qs{ display:grid; grid-template-columns:1fr; gap:12px; }
    .qs-card{ background:#0f1524; border:1px solid var(--border); border-radius:12px; padding:10px; }
    .qs-card .q{font-weight:600; font-size:13px; color:#dfe7ff; margin-bottom:6px}
    .qs-card .rationale{font-size:12px; color:#9aa3b2; margin-bottom:8px}
    .tag-warn{color:#fbbf24}
    .tag-bad{color:#f87171}
    .tag-ok{color:#22c55e}

    /* Validation visuals */
    .invalid{ border-color: var(--warn) !important; }
    .valid{ border-color: rgba(34,197,94,0.35) !important; }

    .prewrap{ white-space: pre-wrap; }

    /* ===== Collapsible cards ===== */
    .qs-header{
      display:flex; align-items:center; justify-content:space-between;
      gap:8px; padding:8px; border-radius:10px; background:#0e1423;
      border:1px solid var(--border); cursor:pointer;
    }
    .qs-header .left{ display:flex; align-items:center; gap:8px; }
    .qs-header .chev{ transition:transform .15s ease; }
    .qs-card.collapsed .qs-body{ display:none; }
    .qs-card.collapsed .chev{ transform:rotate(-90deg); }
    .qs-body .footer{ margin-top:8px; }

    /* ===== In-column loading overlay ===== */
    .loading-overlay{
      position:absolute; inset:0; z-index:5;
      display:flex; align-items:center; justify-content:center;
      background:linear-gradient(180deg, rgba(10,14,25,0.7), rgba(10,14,25,0.7));
      backdrop-filter: blur(2px);
      border-radius:14px;
      border:0;
    }
    .loading-box{ width:min(520px, 92%); display:flex; flex-direction:column; gap:10px; }
    .loading-title{ font-weight:800; letter-spacing:.2px; }
    .loading-meta{ font-size:12px; color:#cbd5e1; }
    .progress-track{ width:100%; height:10px; border-radius:999px; background:#0f1524; border:1px solid var(--border); overflow:hidden; }
    .progress-bar{ height:100%; width:0%; background:var(--accent); transition:width .2s linear; }

    /* ===== Session Setup (sliders) ===== */
    .setup-block{
      padding:10px; border:1px solid var(--border); border-radius:12px;
      background:#0f1524; margin-bottom:8px;
    }
    .setup-grid{
      display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
    }
    .setup-grid label{ margin:0; }
    .setup-help{ font-size:12px; color:var(--muted); margin-top:4px; }
    input[type="range"]{ height:32px; }
    .pill-val{ display:inline-block; min-width:36px; text-align:center; padding:2px 8px; border-radius:999px; background:#101626; border:1px solid var(--border); color:#c8d3eb; font-size:12px;}

    /* ==== HEADER OVERRIDES (brand/title-first, flat, quiet) ==== */
    .topbar{
      position:sticky; top:0; z-index:10;
      background: var(--bg);
      border-bottom:1px solid var(--border);
      padding:12px 16px;
      box-shadow:none;
    }
    .tb-grid{ display:grid; grid-template-columns: 1fr; align-items:center; gap:8px; justify-items:start; }
    .topbar h1{ margin:0; display:flex; align-items:center; gap:8px; font-size:20px; font-weight:700; letter-spacing:.2px; }
    .brand-dot{ width:8px; height:8px; border-radius:50%; display:inline-block; background: var(--accent); box-shadow:0 0 0 2px rgba(59,130,246,.15); }
    .topbar .status, .topbar .tb-right{ display:none !important; }
    @media (min-width:1360px){ .topbar h1{ font-size:22px; } }
    @media (max-width:900px){ .topbar{ padding:10px 12px; } .topbar h1{ font-size:18px; } }
    .topbar.centered .tb-grid{ justify-items:center; }
    .topbar.centered h1{ justify-content:center; }

    /* ==== Underfill banners ==== */
    .underfill{
      background:#221a0e; border:1px solid #6b4b16; color:#f2d29a;
      border-radius:10px; padding:8px; display:flex; gap:8px; align-items:center; justify-content:space-between;
    }
    .underfill .msg{ font-size:13px; }
    .underfill .actions{ display:flex; gap:8px; flex-wrap:wrap; }

    /* ==== Tutorial modal (NEW) ==== */
    body.modal-open{ overflow:hidden; }
    #tutorialBackdrop{
      position:fixed; inset:0; z-index:30;
      display:flex; align-items:center; justify-content:center;
      background:rgba(10,14,25,0.75);
      backdrop-filter:blur(2px);
    }
    #tutorialModal{
      width:min(620px, 94vw);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
      box-shadow:0 2px 24px rgba(0,0,0,0.45);
    }
    .tutorial-title{ font-size:20px; font-weight:800; margin:0 0 6px 0; letter-spacing:.2px; }
    .tutorial-sub{ color:var(--muted); margin-bottom:10px; }
    .tutorial-list{ display:grid; gap:8px; margin:8px 0 12px 0; }
    .tutorial-item{ background:#0f1524; border:1px solid var(--border); border-radius:10px; padding:10px; }
    .tutorial-item .ti-head{ font-weight:700; color:#e6ebff; margin-bottom:4px; }
    .tutorial-item .ti-body{ color:#c8d3eb; font-size:14px; }
    .tutorial-footer{ display:flex; justify-content:flex-end; gap:8px; }
  </style>
</head>

<body>

  <!-- ===== Top bar ===== -->
<header class="topbar">
  <div class="tb-grid">
    <div class="tb-left">
      <h1>
        <span class="brand-dot" aria-hidden="true"></span>
        Doctor Consult Orchestrator — UI Skeleton
        <!-- NEW: help button to reopen tutorial -->
        <button class="btn" id="btnTutorial" type="button" aria-haspopup="dialog" aria-controls="tutorialModal">How it works</button>
      </h1>

      <!-- kept for JS; hidden visually -->
      <span class="status hidden" id="statusBar" aria-live="polite">Ready • Waiting for intake</span>
    </div>

    <!-- kept for JS; hidden visually -->
    <div class="tb-right hidden">
      <span class="pill">v1.4 • count enforcement</span>
      <button class="btn btn-clear" id="btnClear" disabled>Clear Session</button>
    </div>
  </div>
</header>


  <!-- ===== Four-column layout ===== -->
  <main class="container">
    <!-- COLUMN 1: Intake & Picks -->
    <section class="card stack-12" id="col-intake" role="region" aria-labelledby="h2-intake">
      <div class="section-title">
        <h2 class="col-title" id="h2-intake">Intake</h2>
      </div>

      <!-- ===== Session Setup (sliders) ===== -->
      <div class="setup-block" id="sessionSetup">
        <div class="row" style="justify-content:space-between; width:100%;">
          <strong>Session Setup</strong>
          <span class="pill" id="sessionSetupNote">You can change these until Round-1 starts.</span>
        </div>
        <div class="stack-12" style="margin-top:8px;">
          <div class="setup-grid">
            <label for="sliderSpecs">How many specialists (1–10)</label>
            <span class="pill-val" id="outSpecs">—</span>
            <input type="range" id="sliderSpecs" min="1" max="10" step="1" value="5" />
          </div>
          <div class="setup-grid">
            <label for="sliderQs">Questions per specialist (1–10)</label>
            <span class="pill-val" id="outQs">—</span>
            <input type="range" id="sliderQs" min="1" max="10" step="1" value="3" />
          </div>
          <div class="setup-help">Choose counts, then paste the story.</div>
        </div>
      </div>

      <div class="help">Paste the patient’s story here. Model output language follows your config.</div>
      <div>
        <label for="intakeText">Patient story</label>
        <textarea id="intakeText" placeholder="Example: 54-year-old with chest discomfort on exertion, worse over 3 weeks..."></textarea>
      </div>

      <div class="row">
        <button class="btn" id="btnPickAndStartR1" disabled>Pick Specialists &amp; Start Round-1</button>
        <span class="muted" id="sessionSetupSummary">Current: — specialists × — questions/each.</span>
      </div>

      <div class="divider"></div>
      <div class="section-title" style="align-items:center;">
        <h2 class="col-title">Selected Specialists</h2>
        <div class="row" style="gap:8px; align-items:center;">
          <span class="pill-kpi" id="specKpi">0/0</span>
        </div>
      </div>
      <div id="specList" class="stack-8">
        <div class="placeholder">After picking, the chosen specialties and reasons appear here.</div>
      </div>
      <!-- Underfill banner for specialists -->
      <div id="specUnderfillBanner" class="underfill hidden" role="alert" aria-live="polite">
        <div class="msg" id="specUnderfillMsg">Requested N, received M.</div>
        <div class="actions">
          <button class="btn btn-warn" id="btnSpecRetry">Try Again</button>
          <button class="btn btn-accept" id="btnSpecAccept">Lower slider to M</button>
        </div>
      </div>
    </section>

    <!-- COLUMN 2: Round 1 -->
    <section class="card stack-12" id="col-round1" role="region" aria-labelledby="h2-round1">
      <div class="section-title" style="align-items:center;">
        <h2 class="col-title" id="h2-round1">Round-1 Questions (Sequential)</h2>
        <div class="row" style="gap:8px;">
          <span class="pill-kpi" id="r1Kpi">0/0</span>
          <span class="pill" id="r1StepperKpi">0/0 specialists</span>
        </div>
      </div>

      <div id="round1Container" class="stack-12">
        <div class="placeholder">Pick specialists, then start Round-1. You will complete A→B→C… sequentially.</div>
      </div>

      <div class="row">
        <button class="btn" id="btnGenerateR2" disabled>Start Round-2</button>
        <span class="muted">Unlocks after all Round-1 Q&amp;A are completed and any under-fills are resolved (or accepted).</span>
      </div>
    </section>

    <!-- COLUMN 3: Round 2 -->
    <section class="card stack-12" id="col-round2" role="region" aria-labelledby="h2-round2">
      <div class="section-title">
        <h2 class="col-title" id="h2-round2">Round-2 Follow-ups (Sequential)</h2>
        <div class="row" style="gap:8px;">
          <span class="pill" id="r2StepperKpi">0/0 specialists</span>
          <span class="pill">uses all R1 Q&amp;A + prior R2 Q&amp;A</span>
        </div>
      </div>
      <div id="round2Container" class="stack-12">
        <div class="placeholder">Complete Round-1 first, then start Round-2 (A→B→C…).</div>
      </div>

      <div class="row">
        <button class="btn" id="btnGenHypAndConsensus" disabled>Generate Hypotheses &amp; Consensus</button>
        <span class="muted">Enabled after all Round-2 Q&amp;A are completed and any under-fills are resolved (or accepted).</span>
      </div>
    </section>

    <!-- COLUMN 4: Hypotheses + Consensus -->
    <section class="card stack-12" id="col-hypcons" role="region" aria-labelledby="h2-hypcons">
      <div class="section-title" style="align-items:center;">
        <h2 class="col-title" id="h2-hypcons">Diagnostic Hypotheses (per specialty)</h2>
        <div class="row" style="gap:8px;">
          <span class="pill-kpi" id="hypKpi">0/0</span>
          <span class="pill">sequential • retry once</span>
        </div>
      </div>
      <div id="hypothesesContainer" class="stack-12">
        <div class="placeholder">Generate Round-2 before you can generate Hypotheses and Consensus.</div>
      </div>

      <div class="divider"></div>

      <div class="section-title">
        <h2 class="col-title">Consensus Note</h2>
        <span class="pill">copy-ready</span>
      </div>
      <div class="stack-8">
        <div id="consensusNote" class="note" aria-live="polite">[Consensus note will render here]</div>
        <div class="row">
          <button class="btn btn-copy" id="btnCopyNote" disabled>Copy note</button>
          <span class="muted">Copy includes exactly what’s shown above.</span>
        </div>
      </div>
    </section>
  </main>

  <div style="padding:8px 16px; color:var(--muted); font-size:12px;">
    <b>New in v1.4:</b> Count enforcement with auto top-up + clear banners; CTAs only unlock when counts match or you accept fewer.
  </div>

  <!-- =========================================================
       NETWORK: PROXY URL & callProxy helper
       ========================================================= -->
  <script>
  // ====== CONFIG ======
  const PROXY_URL = "https://script.google.com/macros/s/AKfycby1y4LjN60xs1b1wqeiz3VBWh0XQT0yR4wlBYaaq9y24NKqEvCN9Ii5anI19fmOc1wbFQ/exec";

  async function callProxy(body) {
    const res = await fetch(PROXY_URL, {
      method: "POST",
      body: JSON.stringify(body)
    });
    const text = await res.text();
    let json;
    try { json = JSON.parse(text); }
    catch (e) { throw new Error(`Proxy returned non-JSON (${res.status}): ${text.slice(0, 300)}`); }
    if (!json.ok) throw new Error(json.error || 'Unknown proxy error');
    return json.data;
  }
  </script>

  <!-- =========================================================
       CONFIG (values + validation)
       ========================================================= -->
  <script>
  const DEV_MODE = true;
  const DEV_ALLOW_EMPTY_PROMPTS = false;

  const CFG = {
    PROXY_URL: (typeof PROXY_URL === "string" && PROXY_URL) || "",

    COUNTS: {
      NUM_SPECIALISTS: 2,
      QUESTIONS_PER_SPECIALTY_ROUND1: 1,
      QUESTIONS_PER_SPECIALTY_ROUND2: 1
    },

    RUNTIME: {
      SEQUENTIAL_MODE: true,
      RETRY_ONCE: true,
      RETRY_DELAY_MS: 1500,
      PER_CALL_TIMEOUT_MS: 85000,
      ALLOW_BLANK_ANSWERS_R1: false,
      ALLOW_BLANK_ANSWERS_R2: false,

      // Context budget (left as requested)
      R1_MAX_QA_PER_SPECIALTY: 99999,
      ANSWER_MAX_CHARS: 99999999999
    },

    UI: {
      SHOW_STATUS_PANEL: true,
      CONFIRM_ON_CLEAR: true,
      SHOW_COPY_NOTE_BUTTON: true,
      SHOW_HYPOTHESES_PANEL: true,
      TYPICAL_PHASE_MS: 15000
    },

    LANGUAGE_MODE: "AUTO_FROM_INTAKE",

    FEATURES: {
      LEGACY_FIELDS: false,
      CTX_VERSION: "2.0"
    },

    /* ===== PROMPTS (PLACEHOLDERS OK) ===== */
    PROMPTS: {
      PICK_SPECIALISTS: `ROLE
You are “SpecialtyPicker”, a physician-to-physician consult router. Given a free-text patient story, choose the top N medical specialties most likely to own initial workup/management for the primary problem(s).

INPUTS
You will receive a second message that begins with CONTEXT_JSON: containing:
{
  "intakeText": string,               // patient story
  "numSpecialists": number,           // e.g., 5 (N)
  "languageMode": "AUTO_FROM_INTAKE"  // mirror intake language for explanations
}

OBJECTIVE
Return exactly N distinct specialties (no duplicates/near-duplicates), ordered from most to least appropriate. For each, include a concise reason tailored to the intake.

SELECTION RULES (apply in order)
1) Primary ownership: Prefer specialties that will directly evaluate/manage the likely underlying condition(s), not test-only services (Radiology, Pathology) unless they are the primary clinical entry point.
2) Acuity triage: If the story contains red-flag features suggesting imminent risk (e.g., severe/atypical chest pain, focal neuro deficits, sepsis signs, GI bleed, anaphylaxis, obstetric emergency), include **Emergency Medicine** as #1.
3) Age/pregnancy specificity: Use Pediatric- or Geriatric- variants when clearly indicated. Use Obstetrics & Gynecology (or the local-language equivalent) for pregnancy/gynecologic complaints unless another specialty is clearly primary.
4) Granularity: Avoid overlapping picks. Prefer the general home specialty (e.g., Cardiology rather than Interventional Cardiology) unless subspecialty fit is unambiguous and impactful.
5) Breadth vs. scatter: If presentation is multisystem/uncertain without red flags, include a broad gateway specialty (e.g., General Internal Medicine / Family Medicine) once; do not pad with multiple near-identical generalists.
6) Comorbidity weighting: Consider risk factors, meds, chronic conditions, and prior surgeries that meaningfully shift the likely owner (e.g., immunosuppressed with fever → Infectious Diseases higher).
7) Resource realism: Choose specialties that exist commonly in tertiary systems (e.g., Endocrinology, Rheumatology, Neurology, Gastroenterology, Pulmonology, Hematology, Nephrology, Dermatology, Psychiatry, Orthopedic Surgery, General Surgery, Urology, Ophthalmology, Otolaryngology (ENT), Neurosurgery, Vascular Surgery, Allergy/Immunology, Physical Medicine & Rehabilitation, Palliative Care).
8) Geographic/language neutrality: Do not assume country-specific pathways; pick globally recognizable specialty names. If intake language is not English, translate specialty names into that language.

LANGUAGE RULES
- If languageMode is AUTO_FROM_INTAKE, write each "why" in the same language as intakeText. Specialty "name" should also follow intake language when obvious; otherwise use internationally recognizable English terms.
- Keep "why" concise: ideally one sentence ≤ 160 characters, medically precise, and specific to the story (no generic boilerplate).

OUTPUT CONTRACT (STRICT)
- Return only a JSON array with exactly N elements (N = "numSpecialists", default 5 if missing). No preface, no code fences, no trailing comments.
- Each element: { "name": "<Specialty>", "why": "<short reason in intake language>" }
- Do not include other keys. Do not output null/empty items.

QUALITY CHECKS BEFORE YOU OUTPUT (silently apply; do not print these)
- De-duplicate overlapping or synonymous specialties (e.g., "ENT" vs "Otolaryngology" → choose one canonical string).
- Ensure the list is clinically coherent and ordered by a combination of likelihood and impact on immediate management.
- If intakeText is empty/meaningless, still return N reasonable triage owners for undifferentiated complaints starting with: ["General Internal Medicine", "Family Medicine", "Emergency Medicine", …] and then add the next most generally useful gateway specialties.

FINAL OUTPUT FORMAT (example schema; DO NOT ECHO THIS EXAMPLE)
[
  { "name": "Cardiology", "why": "Exertional chest pain with risk factors suggests possible ischemia requiring cardiac evaluation." },
  { "name": "Pulmonology", "why": "Dyspnea and cough with wheeze raise obstructive airway or parenchymal disease considerations." }
]
Return only the array for the actual case.`,

      ROUND1: `ROLE
You are "Round1Questioner", a board-certified specialist physician generating Round-1 history questions for another physician during a live consult. You are acting strictly as the given specialist. Your output is destined for a physician, not a patient.

WHAT YOU WILL RECEIVE NEXT
You will receive a second message that begins with \`CONTEXT_JSON:\` containing a JSON object with EXACT keys:
{
  "intakeText": string,                 // free-text patient story
  "specialist": string,                 // e.g., "Cardiology", "Neurology"
  "numQuestions": number,               // K = number of questions to output
  "languageMode": "AUTO_FROM_INTAKE" | "EN" | "FR",
  "priorQuestions": [                   // optional; previously asked Round-1 questions from earlier specialists
    { "specialist": string, "q": string }
  ]
}

MISSION (ROUND-1 CONTEXT)
You are the specified specialist. Produce exactly K high-yield, clinician-to-clinician history questions to efficiently illuminate the differential for this specialty. Round-1 is for information gathering to inform sharper Round-2 follow-ups later; do NOT attempt to diagnose now.

PRIORITIZATION HEURISTICS (MECE, SPECIALIST LENS)
1) Safety first (can’t-miss): ask to surface red flags and time-sensitive threats for THIS specialty.
2) Discriminators: ask features that split the top plausible diagnostic branches (typical vs atypical patterns; localization; temporality; triggers; modifiers).
3) Risk/context: ask factors that materially change pre-test probability or downstream management (age bands, key comorbidities, meds, exposures, procedures).
4) Management influencers: ask items that would steer initial workup or urgency (severity, progression, prior similar episodes, sentinel negatives that meaningfully lower risk).
5) Non-overlap: every question must capture a distinct clinical datum; no duplicates or near-duplicates.

QUESTION STYLE CONSTRAINTS
- Single-part, focused, answerable succinctly (yes/no, short phrase, number, brief description). No multi-clause “A and B and C?” items.
- Do NOT ask to perform or order tests as a “question”. (It is acceptable if the rationale mentions what the answer would trigger.)
- Physician voice only; adult care; neutral, professional tone appropriate for Québec but globally recognizable.
- Brevity & precision: each "q" ≤ 160 chars; each "rationale" ≤ 160 chars.

LANGUAGE RULES
- If languageMode = "AUTO_FROM_INTAKE": detect from intakeText and write BOTH "q" and "rationale" in that language.
- If languageMode = "EN" or "FR": write in that language regardless of intake language.

CROSS-SPECIALTY DE-DUP RULES (USING priorQuestions)
- Treat priorQuestions as already asked by earlier specialists in this same session.
- For each candidate "q", normalize (lowercase, trim, remove punctuation) and compare semantically to priorQuestions.q.
- If overlapping in meaning (same datum sought, synonyms, or trivial rephrasing), replace with a distinct, high-yield question.
- Also ensure no duplicates within your own K questions.

OUTPUT CONTRACT (STRICT)
- Return ONLY a JSON array with exactly K = numQuestions elements. No preface, no explanations, no code fences.
- Each element MUST be an object with EXACTLY these keys (no others):
  { "q": "<the question text>", "rationale": "<why this matters for this specialist>" }
- Valid JSON: double quotes around keys/strings; no trailing commas.

HIGH-REASONING / HIDDEN SCRATCHPAD
Think deeply and systematically. Use a private scratchpad to reason and check differentials, but DO NOT reveal your chain of thought. Output only the final JSON array that satisfies the contract.

VALIDATION LOOP (APPLY SILENTLY BEFORE OUTPUT)
1) Parse check: would the output parse as JSON? (yes)
2) Count check: array length === numQuestions. (yes)
3) Key check: each item has ONLY "q" and "rationale". (yes)
4) Lens check: every "q" is clearly under the given specialist’s remit. (yes)
5) Yield check: early items prioritize red flags, then discriminators, then management influencers. (yes)
6) De-dup vs priorQuestions and within-set (normalized + semantic). (yes)
7) Language check: matches languageMode rules. (yes)
8) Length check: each "q" and "rationale" ≤ 160 chars. (yes)
9) Prohibited forms: no multi-part questions; no orders/tests framed as questions; no patient-facing advice. (yes)
If any check fails, revise internally and re-validate; only then output.

EXAMPLE SCHEMA (illustrative only — DO NOT ECHO THIS)
[
  { "q": "Characterize chest pain onset, exertional relation, and relief with rest.", "rationale": "Distinguishes stable ischemia vs. non-ischemic patterns for cardiology." }
]
Return only the array for the actual case.`,

      ROUND2: `ROLE
You are "Round2Questioner", a board-certified specialist generating Round-2 follow-up history questions for another physician during a live consult. You are acting strictly as the given specialist. Audience is physician-only (adult care).

WHAT YOU WILL RECEIVE NEXT
You will receive a second message that begins with CONTEXT_JSON: containing a JSON object with EXACT keys:
{
"intakeText": string,
"specialistName": string,
"questionsPerSpecialty": number,
"languageMode": "AUTO_FROM_INTAKE" | "EN" | "FR",
"round1QA": [ { "q": string, "rationale": string, "answer": string } ],
"priorRound2Questions": [ { "specialist": string, "q": string } ]
}

MISSION (ROUND-2 CONTEXT)
Produce exactly K high-yield follow-up questions that:

leverage the specific Round-1 question→answer pairs (round1QA) for THIS specialist,

clarify ambiguities, resolve contradictions, and drill down on discriminators,

quantify severity/tempo/exposures where answers were vague,

escalate or de-escalate based on concerning Round-1 answers (specialist-appropriate red flags),

avoid any overlap with earlier Round-2 questions (priorRound2Questions) or Round-1 Questions (round1QA) (see de-dup rules).

Edge-case fallback: If round1QA is empty or missing (e.g., Round-1 failed for this specialty), generate K high-yield follow-ups based on intakeText alone while still applying all de-dup rules below.

DO NOT

re-ask any datum already captured in round1QA,

re-ask or trivially rephrase any earlier Round-2 item from priorRound2Questions,

ask multi-part questions,

order tests/procedures as a “question,”

write patient-facing advice.

ALLOWED “REFINEMENT” (not a repeat)
It is acceptable to ask a narrower, next-step detail that was NOT obtained in Round-1 and NOT already requested by earlier Round-2 questions.
Examples:

R1 asked “any chest pain?” Answer “yes”; R2 can ask “max duration per episode?” (NOT “do you have chest pain?”)

Earlier Round-2 asked “frequency per day?”; you MAY ask a distinct discriminator like “max duration per episode?” if meaningfully different.

PRIORITIZATION HEURISTICS (SPECIALIST LENS)

Safety first (can’t-miss) prompted by Round-1 answers (e.g., unstable patterns, focal deficits, GI bleed signs, anaphylaxis history).

Discriminators that split the likely differential for THIS specialty (localization, time course, triggers/modifiers, associated features).

Risk/context modifiers (age bands, comorbidities, meds, exposures) only if Round-1 answers imply they are pivotal and still unknown.

Management influencers: details that change initial workup/urgency; avoid trivia.

LANGUAGE RULES

If languageMode = "AUTO_FROM_INTAKE": detect from intakeText and write BOTH "q" and "rationale" in that language.

If languageMode = "EN" or "FR": write in that language regardless of intake language.

DE-DUP RULES (STRICT)
A) Against Round-1 (THIS specialty):

Normalize (lowercase, trim, strip punctuation) and compare meaning to round1QA.q.

DO NOT repeat the same datum; refinements must add a distinct, narrower piece of information.

B) CROSS-SPECIALTY DE-DUP (Round-2 vs earlier Round-2):

If priorRound2Questions is provided, treat those questions as already asked in this session by earlier specialists.

Normalize (lowercase, trim, strip punctuation) and compare semantically to each priorRound2Questions[i].q.

DO NOT repeat or trivially rephrase those earlier items. Ask something meaningfully different that advances THIS specialty’s differential.

C) Within-set:

Ensure no duplicates within your own K Round-2 questions.

QUESTION STYLE CONSTRAINTS

Single, focused, answerable succinctly (yes/no, short phrase, number, brief description).

Avoid compound clauses (“A and B and C?”). Prefer precise, measurable wording.

Each "q" ≤ 160 chars; each "rationale" ≤ 160 chars.

Adult care; physician voice; neutral, professional tone.

OUTPUT CONTRACT (STRICT)
Return ONLY a JSON array with exactly K = questionsPerSpecialty elements. No preface, no explanations, no code fences.
Each element MUST be an object with EXACTLY these keys (no others):
{ "q": "<follow-up question>", "rationale": "<why this matters for this specialist>" }
Valid JSON: double quotes around keys/strings; no trailing commas.

HIDDEN SCRATCHPAD
Think deeply using a private scratchpad, but DO NOT reveal your chain of thought. Output only the final JSON array.

VALIDATION LOOP (APPLY SILENTLY BEFORE OUTPUT)

Parse check: output parses as JSON. (yes)

Count check: array length === questionsPerSpecialty. (yes)

Key check: each item has ONLY "q" and "rationale". (yes)

Lens check: every "q" is clearly under the given specialist’s remit. (yes)

Yield check: start with safety-critical clarifiers prompted by Round-1 answers; then discriminators; then management influencers. (yes)

De-dup vs round1QA and within-set (normalized + semantic). (yes)

Cross-specialty de-dup vs priorRound2Questions (normalized + semantic). (yes)

Language check per languageMode. (yes)

Length check: each field ≤ 160 chars. (yes)

Prohibited forms: no multi-part questions; no orders/tests framed as questions; no patient-facing advice. (yes)

EXAMPLE SCHEMA (illustrative — DO NOT ECHO THIS)
[
{ "q": "Max duration and frequency of chest pain episodes?", "rationale": "Characterizes stability and ischemic likelihood in cardiology." }
]
Return only the JSON array for the actual case.`,

      DIAGNOSTIC_HYPOTHESIS: `ROLE
You are "DiagnosticHypothesisSpecialist", a board-certified physician acting strictly as the specialty named in the context ("specialistName"). Produce one evidence-based diagnostic hypothesis after reviewing prior history Q&A. Audience is physicians (not a patient).

WHAT YOU WILL RECEIVE NEXT
You will receive one message beginning with \`CONTEXT_JSON:\` containing EXACT keys:
{
  "intakeText": string,
  "specialistName": string,                  // e.g., "Cardiology", "Neurology" (this is YOU)
  "languageMode": "AUTO_FROM_INTAKE" | "EN" | "FR",
  "round1QA": [ { "q": string, "rationale": string, "answer": string } ],
  "round2QA": [ { "q": string, "rationale": string, "answer": string } ]
}

RIGOR MANDATE (READ CAREFULLY)
- Mission-critical: failure cannot be tolerated. Think hard, verify every statement.
- Reasoning must be disciplined: explicit uncertainty and clear likelihood shifters.
- Be information-dense and granular; prefer measurable findings over vague phrasing.
- No patient-facing advice. Physician-to-physician tone only.
- Do not reveal your hidden chain-of-thought; output only the required fields.

LANGUAGE
- If languageMode = "AUTO_FROM_INTAKE", match the intakeText’s language.
- If "EN" or "FR", write strictly in that language (medical register).

REFERENCING RULES
- When using prior history, append anchors like [R1-1] or [R2-3], where numbers are 1-based positions in the arrays round1QA / round2QA.

OUTPUT FORMAT (STRICT JSON — THREE KEYS ONLY; ALL STRING VALUES)
Return exactly one JSON object with ONLY these keys. No extra keys, no comments, no code fences.

{
  "diagnosis": string,          // e.g., "Non–ST-elevation myocardial infarction (NSTEMI)"
  "justification": string,      // 5–12 bullets joined as lines starting with "- "
  "steelman": string            // 3–8 bullets joined as lines starting with "- "
}

FORMAT NOTES FOR STRING FIELDS
- For "justification": produce 5–12 bullets, each on its own line, each line starting with "- ".
  Each bullet: concise claim → key positives/negatives → pathophysiologic rationale → anchors/citations.
  Example line: "- Typical exertional chest pain with risk factors increases pretest probability; worsened over weeks. [R1-1,R2-2]"
- For "steelman": produce 3–8 strongest alternative explanations/failure modes with discriminators (tests/exams) and expected findings; include data gaps if present.
  Example line: "- GERD can mimic chest discomfort; discriminator: pain reproducible with meals/PPIs; expected ECG/troponin normal. [R1-3]"

CONSTRAINTS & STANDARDS
- Exactly ONE leading hypothesis (choose the likeliest if tie); do NOT list a differential outside "steelman".
- Use explicit pertinent negatives when they materially reduce probability.
- Never invent clinical facts; if data are insufficient, state the minimal decisive next step within the relevant bullet.
- Prefer recent guidelines/systematic reviews/consensus statements; include year and a working URL.

VALIDATION CHECKLIST (MUST PASS BEFORE OUTPUT)
- [ ] JSON is valid and has ONLY "diagnosis", "justification", "steelman".
- [ ] "justification" has 5–12 "- " bullets (one per line) with ≥1 Q/A anchor.
- [ ] "steelman" has 3–8 "- " bullets (one per line) with concrete discriminators where relevant.
- [ ] Language matches languageMode resolution.
- [ ] No extraneous text, disclaimers, or keys.

Explicitly forbid arrays for justification/steelman.
Ban code fences and any extra text (triple-backticks, “Here is the JSON: …”, etc.).
Bulleting must be newline-separated (not HTML <br>, not semicolons, not blank lines).
Use ASCII hyphen “- ” at line start for bullets.
No empty fields after trimming.
No trailing commas / invalid JSON.
Keep braces out of any surrounding text by forbidding surrounding text entirely.

Double check output format one last time before generating your output. If it does not comply, repeat until it complies.
`,

      CONSENSUS: `ROLE
You are "PanelConsensusMetaSpecialist", a multidisciplinary meta-aggregator emulating a PANEL OF FIVE board-certified specialists. Your job is to run a structured argument among the specialists (internally) and deliver a consensus note for the TWO likeliest diagnoses with exhaustive justification and concrete next steps. The audience is physicians (not a patient).

WHAT YOU WILL RECEIVE NEXT
You will receive one message beginning with \`CONTEXT_JSON:\` containing EXACT keys:
{
"intakeText": string,
"specialists": [ { "name": string, "why": string } ],
"languageMode": "AUTO_FROM_INTAKE" | "EN" | "FR",
"round1": { "<SpecialtyName>": [ { "q": string, "rationale": string, "answer": string } ] },
"round2": { "<SpecialtyName>": [ { "q": string, "rationale": string, "answer": string } ] },
"hypotheses": { // OPTIONAL: per-specialty submissions, keyed by specialty name
"<SpecialtyName>": {
"diagnosis": string,
"justification": string[], // bullets
"steelman": string[] // bullets
}
}
}

RIGOR MANDATE (MISSION-CRITICAL)

FAILURE CANNOT BE TOLERATED. Think hard. Verify every statement. Use disciplined differential logic, explicit uncertainty, and likelihood shifters.

Be thorough and information-dense. Prefer measurable findings, LR+/LR–, validated rules where relevant.

Anchor claims to: (a) prior Q/A by specialty + index, and/or (b)) the submitting specialist’s hypothesis.

You deliberate internally as a panel; DO NOT output the debate transcript. Output only the consensus note.

LANGUAGE

If languageMode = "AUTO_FROM_INTAKE", match the intakeText’s language.

If "EN" or "FR", write strictly in that language (medical register).

ANCHORING FORMAT

Round-1 anchor: [R1:Cardiology:3] means round1["Cardiology"][3].

Round-2 anchor: [R2:Neurology:1] means round2["Neurology"][1].

Specialist anchor: [SP:Cardiology] or [SP:#2] (if you must index).

OUTPUT FORMAT (STRICT JSON — ONE KEY ONLY)
Return exactly ONE JSON object with ONLY this key. No extra keys, no comments, no code fences.

{
"noteText": "..." // a single copy-ready physician note (markdown-like allowed)
}

REQUIRED NOTE SECTIONS (IN ORDER)

Title line:

“Consensus Panel — Two Likeliest Diagnoses”

Diagnoses (ranked 1→2):

<Concise, specific label>

<Concise, specific label>

Justification for Dx #1 (bulleted, granular):

Include pertinent positives/negatives from Q/A with anchors, brief pathophysiology, likelihood shifts; resolve main counterpoints.

Justification for Dx #2 (bulleted, granular):

Same depth and anchoring discipline as Dx #1.

Next Steps (prioritized, clinician-directed):

Each item: action → purpose → discriminator/expected findings → effect on Dx#1 vs Dx#2; end each with ≥1 anchor.

Panel Provenance:

List the contributing specialties (names), and whether each supported Dx#1, Dx#2, or dissented, referencing \`hypotheses\` if provided.

CONSTRAINTS & VALIDATION

Exactly TWO distinct diagnoses in the ranked list.

Every justification bullet and next-step item ends with ≥1 valid anchor.

Never invent clinical facts; if data are insufficient, state the minimal decisive next step inside the relevant bullet.

Use guidelines/systematic reviews/consensus where relevant.

Language matches languageMode. No boilerplate beyond the required sections.

BEGIN WHEN READY
Wait for the next message beginning with \`CONTEXT_JSON:\`. Parse it and respond with exactly:
{ "noteText": "<the complete consensus note as specified>" }.`
    }
  };

  function validateConfig(cfg) {
    const issues = [];
    if (!cfg || typeof cfg !== "object") { issues.push("CFG is missing or not an object."); return issues; }

    if (!cfg.PROXY_URL || typeof cfg.PROXY_URL !== "string") {
      issues.push("PROXY_URL is missing or not a string.");
    } else {
      const looksLikeGAS = cfg.PROXY_URL.startsWith("https://script.google.com/macros/");
      const endsWithExec = cfg.PROXY_URL.includes("/exec");
      if (!looksLikeGAS || !endsWithExec) issues.push("PROXY_URL does not look like a Google Apps Script Web App /exec URL.");
    }

    const c = cfg.COUNTS || {};
    if (!Number.isInteger(c.NUM_SPECIALISTS) || c.NUM_SPECIALISTS < 1) issues.push("COUNTS.NUM_SPECIALISTS must be an integer >= 1.");
    if (!Number.isInteger(c.QUESTIONS_PER_SPECIALTY_ROUND1) || c.QUESTIONS_PER_SPECIALTY_ROUND1 < 1) issues.push("COUNTS.QUESTIONS_PER_SPECIALTY_ROUND1 must be an integer >= 1.");
    if (!Number.isInteger(c.QUESTIONS_PER_SPECIALTY_ROUND2) || c.QUESTIONS_PER_SPECIALTY_ROUND2 < 1) issues.push("COUNTS.QUESTIONS_PER_SPECIALTY_ROUND2 must be an integer >= 1.");

    const r = cfg.RUNTIME || {};
    ["SEQUENTIAL_MODE","RETRY_ONCE","ALLOW_BLANK_ANSWERS_R1","ALLOW_BLANK_ANSWERS_R2"].forEach(k=>{
      if (typeof r[k] !== "boolean") issues.push(`RUNTIME.${k} must be true/false.`);
    });
    [["RETRY_DELAY_MS",0],["PER_CALL_TIMEOUT_MS",1000]].forEach(([k,min])=>{
      if (!Number.isInteger(r[k]) || r[k] < min) issues.push(`RUNTIME.${k} must be an integer >= ${min} (ms).`);
    });

    const u = cfg.UI || {};
    ["SHOW_STATUS_PANEL","CONFIRM_ON_CLEAR","SHOW_COPY_NOTE_BUTTON","SHOW_HYPOTHESES_PANEL"].forEach(k=>{
      if (typeof u[k] !== "boolean") issues.push(`UI.${k} must be true/false.`);
    });

    const p = cfg.PROMPTS || {};
    ["PICK_SPECIALISTS","ROUND1","ROUND2","DIAGNOSTIC_HYPOTHESIS","CONSENSUS"].forEach(key => {
      const val = p[key];
      if (typeof val !== "string") issues.push(`PROMPTS.${key} must be a string (use backticks).`);
      else if (!val.trim() && !DEV_ALLOW_EMPTY_PROMPTS) issues.push(`PROMPTS.${key} is empty. Paste your prompt.`);
    });

    return issues;
  }

  function deepFreeze(obj) {
    if (!obj || typeof obj !== "object") return obj;
    Object.getOwnPropertyNames(obj).forEach(name => {
      const value = obj[name];
      if (value && typeof value === "object") deepFreeze(value);
    });
    return Object.freeze(obj);
  }

  (function initConfig() {
    const problems = validateConfig(CFG);
    if (problems.length) {
      const message = "CONFIG ISSUES:\n- " + problems.join("\n- ");
      if (DEV_MODE) { alert(message); console.error(message); }
      else { throw new Error(message); }
    } else {
      console.log("%cConfig OK", "color: green; font-weight: bold;");
    }
    deepFreeze(CFG);
    window.__CFG = CFG; // Read-only
  })();
  </script>

<!-- ===== Tutorial Modal Markup (NEW) ===== -->
  <div id="tutorialBackdrop" class="hidden" aria-hidden="true">
    <div id="tutorialModal" role="dialog" aria-modal="true" aria-labelledby="tutorialTitle">
      <div class="tutorial-title" id="tutorialTitle">What this app does</div>
      <div class="tutorial-sub">Consult with a board of AI medical specialists. Saving you about 500$ per specialist selected</div>

      <div class="tutorial-list">
        <div class="tutorial-item">
          <div class="ti-head">1 · Set Up</div>
          <div class="ti-body">Use the sliders to choose how many medical specialists and questions per specialist, then write your symptoms.</div>
        </div>
        <div class="tutorial-item">
          <div class="ti-head">2 · Round 1</div>
          <div class="ti-body">Answer each specialist’s questions.</div>
        </div>
        <div class="tutorial-item">
          <div class="ti-head">3 · Round 2</div>
          <div class="ti-body">Answer each specialist’s follow-up questions.</div>
        </div>
        <div class="tutorial-item">
          <div class="ti-head">4 · Finish Up</div>
          <div class="ti-body">Get a full diagnosis hypothesis, consensus summary, and next-step plan — instantly (well, it does take a few minutes).</div>
        </div>
      </div>

      <div class="tutorial-footer">
        <button class="btn btn-accept" id="tutorialOk" type="button" aria-label="Close tutorial">OK</button>
      </div>
    </div>
  </div>

  <!-- =========================================================
       APP LOGIC — sequential R1/R2 + cross-specialty context
       + Session Setup sliders & live settings
       + Collapsible cards + end-of-round CTA logic + precise labels
       + NEW: Count enforcement with retry/top-up + underfill banners
       + NEW: Tutorial modal (one-time auto-show + header button)
       ========================================================= -->
  <script>
  // ---------- Live settings (mutable) + getters ----------
  const __LIVE = {
    numSpecialists: window.__CFG.COUNTS.NUM_SPECIALISTS,
    questionsPerSpecialist: window.__CFG.COUNTS.QUESTIONS_PER_SPECIALTY_ROUND1
  };
  function clampInt(n, min, max){ n = parseInt(n,10); if (isNaN(n)) n=min; return Math.max(min, Math.min(max, n)); }
  function getNumSpecialists(){ return clampInt(__LIVE.numSpecialists, 1, 10); }
  function getQCountR1(){ return clampInt(__LIVE.questionsPerSpecialist, 1, 10); }
  function getQCountR2(){ return getQCountR1(); } // same value by design for now

  // ---------- DOM refs ----------
  const intakeEl = document.getElementById('intakeText');
  const pickAndStartR1Btn = document.getElementById('btnPickAndStartR1');

  const statusEl = document.getElementById('statusBar');
  const clearBtn = document.getElementById('btnClear');

  const genR2Btn = document.getElementById('btnGenerateR2');

  const round1Container = document.getElementById('round1Container');
  const round2Container = document.getElementById('round2Container');
  const r1KpiEl = document.getElementById('r1Kpi');
  const r1StepperKpiEl = document.getElementById('r1StepperKpi');
  const r2StepperKpiEl = document.getElementById('r2StepperKpi');

  const hypContainer = document.getElementById('hypothesesContainer');
  const hypKpiEl     = document.getElementById('hypKpi');

  const genHypAndConBtn = document.getElementById('btnGenHypAndConsensus');
  const consensusNoteEl = document.getElementById('consensusNote');
  const copyBtn      = document.getElementById('btnCopyNote');

  // Session Setup slider refs
  const sliderSpecs = document.getElementById('sliderSpecs');
  const sliderQs    = document.getElementById('sliderQs');
  const outSpecs    = document.getElementById('outSpecs');
  const outQs       = document.getElementById('outQs');
  const specKpiEl   = document.getElementById('specKpi');
  const sessionSetupSummaryEl = document.getElementById('sessionSetupSummary');

  // Underfill banner refs (specialists)
  const specUnderfillBanner = document.getElementById('specUnderfillBanner');
  const specUnderfillMsg = document.getElementById('specUnderfillMsg');
  const btnSpecRetry = document.getElementById('btnSpecRetry');
  const btnSpecAccept = document.getElementById('btnSpecAccept');

  // NEW: Tutorial refs
  const tutorialBackdrop = document.getElementById('tutorialBackdrop');
  const tutorialModal = document.getElementById('tutorialModal');
  const tutorialOk = document.getElementById('tutorialOk');
  const btnTutorial = document.getElementById('btnTutorial');
  const TUTORIAL_SEEN_KEY = 'dco_tutorial_seen_v1';

  // ---------- Session (memory-only) ----------
  let session = makeEmptySession();
  function makeEmptySession(){
    return {
      patient_intake: "",
      specialists: [],            // [{name, why}]
      round1: {},                 // { [specName]: [{q,rationale,answer}] }
      round2: {},                 // { [specName]: [{q,rationale,answer}] }
      hypotheses: {},             // { [specName]: { diagnosis, justification, steelman } }
      consensus: { noteText: "" }
    };
  }

  // ---------- Local UI/state ----------
  const __STATE = {
    stage: 'intake',
    r1Locked: false,
    hypothesesRan: false,
    r1Idx: null,
    r2Idx: null,
    // NEW: underfill tracking (per index)
    r1Underfill: {}, // { [specIdx]: {requested, received, accepted:boolean} }
    r2Underfill: {},  // { [specIdx]: {requested, received, accepted:boolean} }
    // NEW: tutorial
    tutorialOpen: false
  };

  const STAGE_TO_COL = {
    intake:  'col-intake',
    r1:      'col-round1',
    r2:      'col-round2',
    hypcons: 'col-hypcons'
  };

  function logStageChange(from, to, note){
    if (from !== to) console.log('[stage]', from, '→', to, note ? `(${note})` : '');
  }
  function setStage(newStage, note){
    const prev = __STATE.stage;
    __STATE.stage = newStage;
    logStageChange(prev, newStage, note);
    if (!CURRENT_PHASE) applyActiveColumn(computeActiveColumn());
  }

  function setStatus(msg){ if(statusEl) statusEl.textContent = msg; }
  function delay(ms){ return new Promise(res => setTimeout(res, ms)); }
  function escapeHtml(s){
    return String(s ?? "")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  // ====== RETRY with overlay attempt reset ======
  async function withRetry(fn, retries, beforeAttempt){
    let lastErr;
    for (let attempt = 0; attempt <= retries; attempt++){
      if (typeof beforeAttempt === 'function') {
        try { beforeAttempt(attempt, retries + 1); } catch(_) {}
      }
      try { return await fn(); }
      catch (err){
        lastErr = err;
        if (attempt < retries) await delay(window.__CFG.RUNTIME.RETRY_DELAY_MS);
      }
    }
    throw lastErr;
  }

  async function callProxyWithTimeout(body, timeoutMs){
    return await Promise.race([
      callProxy(body),
      new Promise((_, reject) => setTimeout(() => reject(new Error(`Timeout after ${timeoutMs} ms`)), timeoutMs))
    ]);
  }

  function setRound1Lock(locked) {
    __STATE.r1Locked = !!locked;
    if (locked) setStatus('Round-1 complete — Start Round-2.');
  }

  // ---------- Busy guard ----------
  let _busy = false;
  function setBusy(isBusy, phaseLabel){
    _busy = isBusy;
    if (isBusy && phaseLabel) setStatus(`${phaseLabel}`);
    setButtonsState();
  }

  // ---------- Validation visuals ----------
  function setAnswerValidityClass(textareaEl, isValid) {
    if (!textareaEl) return;
    textareaEl.classList.remove('invalid','valid');
    textareaEl.classList.add(isValid ? 'valid' : 'invalid');
  }

  // ---------- Progress helpers (R1) ----------
  function areAllRequiredR1AnsweredOnly(){
    for (const spec of session.specialists){
      const name = spec?.name || '';
      const arr = session.round1[name];
      if (!Array.isArray(arr) || arr.length === 0) return false;
      if (!window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R1){
        for (const item of arr){ if ((item?.answer || '').trim().length === 0) return false; }
      }
    }
    return session.specialists.length > 0;
  }
  function updateR1TotalsUI() {
    let totalRequired = 0, answered = 0, completedSpecs = 0;
    session.specialists.forEach(({name}, idx) => {
      const arr = session.round1[name] || [];
      if (arr.length) {
        totalRequired += arr.length;
        let specAnswered = 0;
        arr.forEach(it => { if ((it?.answer || '').trim().length > 0) specAnswered++; });
        answered += specAnswered;
        if (specAnswered === arr.length) completedSpecs++;
        const hk = document.getElementById(`r1h-${idx}`);
        if (hk) hk.textContent = `${specAnswered}/${arr.length}`;
        const fk = document.getElementById(`r1p-${idx}`);
        if (fk) fk.textContent = `${specAnswered}/${arr.length}`;
      }
    });
    if (r1KpiEl) r1KpiEl.textContent = `${answered}/${totalRequired}`;
    if (r1StepperKpiEl) r1StepperKpiEl.textContent = `${completedSpecs}/${session.specialists.length} specialists`;
  }

  // ---------- Progress helpers (R2) ----------
  function areAllRequiredR2AnsweredOnly() {
    for (const spec of session.specialists) {
      const name = spec?.name || '';
      const arr = session.round2[name];
      if (!Array.isArray(arr) || arr.length === 0) return false;
      if (!window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R2) {
        for (const item of arr) if ((item?.answer || '').trim().length === 0) return false;
      }
    }
    return session.specialists.length > 0;
  }
  function updateR2TotalsUI() {
    let completedSpecs = 0;
    session.specialists.forEach(({name}, idx) => {
      const arr = session.round2[name] || [];
      let specAnswered = 0;
      arr.forEach(it => { if ((it?.answer||'').trim().length>0) specAnswered++; });
      const fk = document.getElementById(`r2p-${idx}`);
      if (fk) fk.textContent = `${specAnswered}/${arr.length||0}`;
      if (arr.length && arr.every(it => (it?.answer||'').trim().length > 0)) completedSpecs++;
    });
    if (r2StepperKpiEl) r2StepperKpiEl.textContent = `${completedSpecs}/${session.specialists.length} specialists`;
  }

  // ===================== ACTIVE COLUMN + OVERLAY =====================
  const COLUMN_IDS = ['col-intake','col-round1','col-round2','col-hypcons'];
  let CURRENT_PHASE = null;

  function applyActiveColumn(colId){
    COLUMN_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      const active = (id === colId);
      el.classList.toggle('is-active', active);
      if (active) el.setAttribute('aria-current','step'); else el.removeAttribute('aria-current');
    });
  }

  function computeActiveColumn(){
    if (CURRENT_PHASE && CURRENT_PHASE.colId) return CURRENT_PHASE.colId;
    if (__STATE.stage && STAGE_TO_COL[__STATE.stage]) return STAGE_TO_COL[__STATE.stage];
    if (session && session.consensus && (session.consensus.noteText || '').trim().length > 0) return 'col-hypcons';
    return 'col-intake';
  }

  // ===== Precise overlay labels =====
  function makePhaseLabel(kind, o={}){
    const idx = Number(o.idx||0), total = Number(o.total||0);
    const specName = o.specName ? ` (${o.specName})` : '';
    const rq = (n)=> (n===1?'question':'questions');
    switch(kind){
      case 'pick': return 'Loading specialist list from intake…';
      case 'pick-topup': return 'Trying to top-up specialists…';
      case 'r1': return `Loading specialist ${idx} of ${total} — ${getQCountR1()} ${rq(getQCountR1())} — Round 1 of 2${specName}`;
      case 'r1-topup': return `Top-up ${idx} of ${total} — fetching missing Round-1 questions${specName}`;
      case 'r2': return `Loading specialist ${idx} of ${total} — ${getQCountR2()} ${rq(getQCountR2())} — Round 2 of 2${specName}`;
      case 'r2-topup': return `Top-up ${idx} of ${total} — fetching missing Round-2 questions${specName}`;
      case 'hyp': return `Loading diagnostic for specialist ${idx} of ${total}${specName}`;
      case 'consensus': return 'Loading consensus';
      default: return 'Working…';
    }
  }

  // Overlay
  let _overlayEl = null, _overlayTimer = null, _overlayStart = 0, _overlayMax = 0;

  function _fmtTime(ms){
    const s = Math.max(0, Math.ceil(ms/1000));
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s % 60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function _mountOverlay(colId, title){
    _unmountOverlay();
    const host = document.getElementById(colId);
    if (!host) return;
    const el = document.createElement('div');
    el.className = 'loading-overlay';
    el.id = 'phaseOverlay';
    el.setAttribute('role','status');
    el.setAttribute('aria-live','polite');
    el.innerHTML = `
      <div class="loading-box">
        <div class="loading-title" id="overlayTitle">${escapeHtml(title || 'Working…')}</div>
        <div class="loading-meta" id="overlayMeta"><span id="overlayCountdown">--:--</span> remaining • typically ~${Math.round((window.__CFG.UI.TYPICAL_PHASE_MS||15000)/1000)} s</div>
        <div class="progress-track"><div class="progress-bar" id="overlayBar" style="width:0%"></div></div>
      </div>`;
    host.appendChild(el);
    _overlayEl = el;
  }

  function _unmountOverlay(){
    if (_overlayTimer) { clearInterval(_overlayTimer); _overlayTimer = null; }
    if (_overlayEl && _overlayEl.parentNode) _overlayEl.parentNode.removeChild(_overlayEl);
    _overlayEl = null; _overlayStart = 0; _overlayMax = 0;
  }

  function beginPhase(phaseKey, colId, title){
    CURRENT_PHASE = { key: String(phaseKey||'phase'), colId: String(colId) };
    applyActiveColumn(colId);
    _mountOverlay(colId, title || 'Working…');
    resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, 0, (window.__CFG.RUNTIME.RETRY_ONCE?2:1));
    setStatus(title || 'Working…'); // keep status bar in sync
  }

  function resetOverlayAttempt(maxMs, attemptIndex, totalAttempts){
    if (!_overlayEl) return;
    _overlayStart = Date.now();
    _overlayMax = Math.max(1000, Number(maxMs)||window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS);
    const countdownEl = document.getElementById('overlayCountdown');
    const barEl = document.getElementById('overlayBar');
    const titleEl = document.getElementById('overlayTitle');
    if (titleEl && typeof attemptIndex === 'number' && typeof totalAttempts === 'number' && totalAttempts > 1){
      const base = titleEl.textContent.split(' (Attempt')[0];
      titleEl.textContent = `${base} (Attempt ${attemptIndex+1}/${totalAttempts})`;
    }
    if (_overlayTimer) { clearInterval(_overlayTimer); _overlayTimer = null; }
    function tick(){
      const elapsed = Date.now() - _overlayStart;
      const remaining = Math.max(0, _overlayMax - elapsed);
      if (countdownEl) countdownEl.textContent = _fmtTime(remaining);
      if (barEl) {
        const p = Math.min(100, Math.max(0, (elapsed / _overlayMax)*100));
        barEl.style.width = `${p}%`;
      }
      if (remaining <= 0){
        clearInterval(_overlayTimer); _overlayTimer = null;
      }
    }
    tick();
    _overlayTimer = setInterval(tick, 1000);
  }

  function endPhase(){
    _unmountOverlay();
    CURRENT_PHASE = null;
    applyActiveColumn(computeActiveColumn());
  }

  // ---------- Buttons state ----------
  function hasPickUnderfill(){
    return session.specialists.length > 0 && session.specialists.length < getNumSpecialists();
  }
  function areAllR1CardsCountsSatisfiedOrAccepted(){
    // For each specialist, if count < requested and not accepted -> false
    for (let idx=0; idx<session.specialists.length; idx++){
      const specName = session.specialists[idx]?.name || '';
      const arr = session.round1[specName] || [];
      const requested = getQCountR1();
      if (arr.length < requested){
        const uf = __STATE.r1Underfill[idx];
        if (!uf || uf.accepted !== true) return false;
      }
    }
    return true;
  }
  function areAllR2CardsCountsSatisfiedOrAccepted(){
    for (let idx=0; idx<session.specialists.length; idx++){
      const specName = session.specialists[idx]?.name || '';
      const arr = session.round2[specName] || [];
      const requested = getQCountR2();
      if (arr.length < requested){
        const uf = __STATE.r2Underfill[idx];
        if (!uf || uf.accepted !== true) return false;
      }
    }
    return true;
  }
  function areAllR1ReadyToAdvance(){
    return areAllRequiredR1AnsweredOnly() && areAllR1CardsCountsSatisfiedOrAccepted();
  }
  function areAllR2ReadyToAdvance(){
    return areAllRequiredR2AnsweredOnly() && areAllR2CardsCountsSatisfiedOrAccepted();
  }

  function setButtonsState() {
    const hasIntake = (intakeEl.value || '').trim().length > 0;

    // Intake → R1 button (also block if underfill specialists not accepted)
    if (pickAndStartR1Btn) {
      const inR1Stepper = __STATE.r1Idx !== null;
      const blockedByUnderfill = hasPickUnderfill();
      pickAndStartR1Btn.disabled = (!hasIntake || _busy || __STATE.r1Locked || inR1Stepper || blockedByUnderfill);
    }

    clearBtn.disabled = !hasIntake && session.specialists.length === 0;

    if (genR2Btn) {
      const inR2Stepper = __STATE.r2Idx !== null;
      genR2Btn.disabled = (!areAllR1ReadyToAdvance() || _busy || inR2Stepper);
    }

    if (genHypAndConBtn) genHypAndConBtn.disabled = !areAllR2ReadyToAdvance() || _busy;

    copyBtn.disabled = !(session.consensus && session.consensus.noteText && session.consensus.noteText.trim().length);

    updateR1TotalsUI();
    updateR2TotalsUI();
    updateHypProgressUI();

    if (!CURRENT_PHASE) applyActiveColumn(computeActiveColumn());

    if (sessionSetupSummaryEl) {
      sessionSetupSummaryEl.textContent = `Current: ${getNumSpecialists()} specialists × ${getQCountR1()} questions/each.`;
    }

    // Specialists underfill banner visibility
    updateSpecUnderfillBanner();
  }

  // ---------- Intake typing gates buttons ----------
  intakeEl.addEventListener('input', () => {
    const hasText = (intakeEl.value || '').trim().length > 0;
    if (pickAndStartR1Btn) pickAndStartR1Btn.disabled = __STATE.r1Locked ? true : (!hasText || _busy || __STATE.r1Idx !== null || hasPickUnderfill());
    setStatus(hasText ? 'Ready • Intake captured' : 'Ready • Waiting for intake');
    if (!CURRENT_PHASE) applyActiveColumn(computeActiveColumn());
  });

  // ---------- Column 1 specialist summary ----------
  function renderSpecSummary(list){
    const specListEl = document.getElementById('specList');
    const kpiEl = document.getElementById('specKpi');
    if (kpiEl) {
      const count = Array.isArray(list) ? list.length : 0;
      kpiEl.textContent = `${count}/${getNumSpecialists()}`;
    }
    if (!specListEl) return;
    if (!Array.isArray(list) || !list.length){
      specListEl.innerHTML = '<div class="placeholder">No specialists returned. You can try again.</div>';
      return;
    }
    const html = list.map((spec, idx) => {
      const letter = String.fromCharCode(65 + idx);
      return `<div class="row">
        <span class="pill" style="min-width:28px; justify-content:center;">${letter}</span>
        <div>${escapeHtml(spec.name || '')} — <span class="muted">${escapeHtml(spec.why || '')}</span></div>
      </div>`;
    }).join('');
    specListEl.innerHTML = html;
    updateSpecUnderfillBanner();
  }

  // =========================
  // Normalization & de-dup helpers
  // =========================
  function normalizeQuestionText(t) {
    const s = String(t || '').toLowerCase().trim().replace(/\s+/g,' ');
    return s.replace(/[^\p{L}\p{N}\s]/gu, '');
  }
  function normalizeAnswerText(t){
    return String(t || '').toLowerCase().trim().replace(/\s+/g,' ');
  }
  function normalizeSpecialistName(t){
    return String(t || '').toLowerCase().trim();
  }
  function dedupByTriple(list){
    const seen = new Set();
    const out = [];
    for (const item of (Array.isArray(list) ? list : [])){
      const s = normalizeSpecialistName(item && item.specialist);
      const q = normalizeQuestionText(item && item.q);
      const a = normalizeAnswerText(item && item.answer);
      if (!q) continue;
      const key = `${s}||${q}||${a}`;
      if (!seen.has(key)){ seen.add(key); out.push(item); }
    }
    return out;
  }
  function dedupQuestionsWithinSpecialist(items){
    const seen = new Set();
    const out = [];
    for (const it of (Array.isArray(items)?items:[])){
      const key = normalizeQuestionText(it && it.q);
      if (!key) continue;
      if (!seen.has(key)){ seen.add(key); out.push(it); }
    }
    return out;
  }
  function dedupSpecialistsByName(items){
    const seen = new Set();
    const out = [];
    for (const it of (Array.isArray(items)?items:[])){
      const key = normalizeSpecialistName(it && it.name);
      if (!key) continue;
      if (!seen.has(key)){ seen.add(key); out.push(it); }
    }
    return out;
  }

  // =========================
  // Context builders (Q&A)
  // =========================
  function _truncateAnswer(s) {
    const max = window.__CFG.RUNTIME.ANSWER_MAX_CHARS;
    const t = String(s || '');
    if (t.length <= max) return t;
    return t.slice(0, max) + '…';
  }

  function buildPriorRound1QA(currentIdx) {
    const out = [];
    for (let i = 0; i < currentIdx; i++) {
      const specName = session.specialists[i]?.name || '';
      const arr = session.round1[specName];
      if (!Array.isArray(arr) || !arr.length) continue;
      for (const item of arr) {
        const a = (item?.answer || '').trim();
        if (!a) continue;
        out.push({ specialist: specName, q: String(item.q||''), answer: _truncateAnswer(a) });
      }
    }
    return dedupByTriple(out);
  }

  function buildPriorRound2QA(currentIdx) {
    const out = [];
    for (let i = 0; i < currentIdx; i++) {
      const specName = session.specialists[i]?.name || '';
      const arr = session.round2[specName];
      if (!Array.isArray(arr) || !arr.length) continue;
      for (const item of arr) {
        const a = (item?.answer || '').trim();
        if (!a) continue;
        out.push({ specialist: specName, q: String(item.q||''), answer: _truncateAnswer(a) });
      }
    }
    return dedupByTriple(out);
  }

  function buildAllRound1BySpecialtyExcluding(excludeName){
    const out = {};
    for (const {name} of session.specialists) {
      if (!name || name === excludeName) continue;
      const arr = session.round1[name] || [];
      const answered = arr
        .filter(x => (x?.answer||'').trim().length > 0)
        .map(({q,rationale,answer}) => ({ q: String(q||''), rationale: String(rationale||''), answer: _truncateAnswer(answer||'') }));
      out[name] = dedupQuestionsWithinSpecialist(answered);
    }
    return out;
  }
  function buildAllRound2BySpecialtyExcluding(excludeName){
    const out = {};
    for (const {name} of session.specialists) {
      if (!name || name === excludeName) continue;
      const arr = session.round2[name] || [];
      const answered = arr
        .filter(x => (x?.answer||'').trim().length > 0)
        .map(({q,rationale,answer}) => ({ q: String(q||''), rationale: String(rationale||''), answer: _truncateAnswer(answer||'') }));
      out[name] = dedupQuestionsWithinSpecialist(answered);
    }
    return out;
  }

  function buildAllRound1BySpecialty(){
    const out = {};
    for (const {name} of session.specialists) {
      const arr = session.round1[name] || [];
      const answered = arr
        .filter(x => (x?.answer||'').trim().length > 0)
        .map(({q,rationale,answer}) => ({ q: String(q||''), rationale: String(rationale||''), answer: _truncateAnswer(answer||'') }));
      out[name] = dedupQuestionsWithinSpecialist(answered);
    }
    return out;
  }
  function buildAllRound2BySpecialty(){
    const out = {};
    for (const {name} of session.specialists) {
      const arr = session.round2[name] || [];
      const answered = arr
        .filter(x => (x?.answer||'').trim().length > 0)
        .map(({q,rationale,answer}) => ({ q: String(q||''), rationale: String(rationale||''), answer: _truncateAnswer(answer||'') }));
      out[name] = dedupQuestionsWithinSpecialist(answered);
    }
    return out;
  }

  // =========================
  // Collapsible helpers
  // =========================
  function bindCollapseToggle(card, headerId){
    const header = card.querySelector(`#${headerId}`);
    if (!header) return;
    header.addEventListener('click', () => {
      const collapsed = card.classList.toggle('collapsed');
      header.setAttribute('aria-expanded', String(!collapsed));
    });
  }
  function collapseCard(card, yes){
    if (!card) return;
    card.classList.toggle('collapsed', !!yes);
    const header = card.querySelector('.qs-header');
    if (header) header.setAttribute('aria-expanded', String(!yes));
  }
  function collapseAllBefore(containerEl, idx, prefix){
    if (!containerEl) return;
    for (let i=0;i<idx;i++){
      const card = document.getElementById(`${prefix}${i}`);
      collapseCard(card, true);
    }
  }

  // =========================
  // R1 Underfill banner helpers
  // =========================
  function ensureR1UnderfillBanner(specIdx, specName, requested, received){
    const card = document.getElementById(`r1-s-${specIdx}`);
    if (!card) return;
    let banner = card.querySelector('.underfill[data-scope="r1"]');
    if (!banner){
      banner = document.createElement('div');
      banner.className = 'underfill';
      banner.setAttribute('data-scope','r1');
      banner.innerHTML = `
        <div class="msg"></div>
        <div class="actions">
          <button class="btn btn-warn">Top-up</button>
          <button class="btn btn-accept">Accept fewer</button>
        </div>`;
      const body = card.querySelector('.qs-body');
      body.insertAdjacentElement('afterbegin', banner);
    }
    const msg = banner.querySelector('.msg');
    const btnTopup = banner.querySelector('.btn-warn');
    const btnAccept = banner.querySelector('.btn-accept');
    msg.textContent = `Requested ${requested} questions, currently have ${received}.`;
    banner.classList.toggle('hidden', received >= requested);

    btnTopup.onclick = async () => {
      await topUpR1Questions(specIdx, specName, requested);
    };
    btnAccept.onclick = () => {
      __STATE.r1Underfill[specIdx] = { requested, received, accepted: true };
      banner.classList.add('hidden');
      setButtonsState();
      // Also re-evaluate local next button enablement
      const localNextBtn = document.getElementById(`btnR1Next-${specIdx}`);
      if (localNextBtn) {
        const specComplete = isSpecR1Complete(specName);
        const okUnderfill = isR1UnderfillSatisfiedOrAccepted(specIdx, requested);
        localNextBtn.disabled = !(specComplete && okUnderfill);
      }
    };
  }
  function isR1UnderfillSatisfiedOrAccepted(specIdx, requested){
    const specName = session.specialists[specIdx]?.name || '';
    const arr = session.round1[specName] || [];
    if (arr.length >= requested) return true;
    const uf = __STATE.r1Underfill[specIdx];
    return !!(uf && uf.accepted === true);
  }

  // =========================
  // R2 Underfill banner helpers
  // =========================
  function ensureR2UnderfillBanner(specIdx, specName, requested, received){
    const card = document.getElementById(`r2-s-${specIdx}`);
    if (!card) return;
    let banner = card.querySelector('.underfill[data-scope="r2"]');
    if (!banner){
      banner = document.createElement('div');
      banner.className = 'underfill';
      banner.setAttribute('data-scope','r2');
      banner.innerHTML = `
        <div class="msg"></div>
        <div class="actions">
          <button class="btn btn-warn">Top-up</button>
          <button class="btn btn-accept">Accept fewer</button>
        </div>`;
      const body = card.querySelector('.qs-body');
      body.insertAdjacentElement('afterbegin', banner);
    }
    const msg = banner.querySelector('.msg');
    const btnTopup = banner.querySelector('.btn-warn');
    const btnAccept = banner.querySelector('.btn-accept');
    msg.textContent = `Requested ${requested} follow-ups, currently have ${received}.`;
    banner.classList.toggle('hidden', received >= requested);

    btnTopup.onclick = async () => {
      await topUpR2Questions(specIdx, specName, requested);
    };
    btnAccept.onclick = () => {
      __STATE.r2Underfill[specIdx] = { requested, received, accepted: true };
      banner.classList.add('hidden');
      setButtonsState();
      const localNextBtn = document.getElementById(`btnR2Next-${specIdx}`);
      if (localNextBtn) {
        const specComplete = isSpecR2Complete(specName);
        const okUnderfill = isR2UnderfillSatisfiedOrAccepted(specIdx, requested);
        localNextBtn.disabled = !(specComplete && okUnderfill);
      }
    };
  }
  function isR2UnderfillSatisfiedOrAccepted(specIdx, requested){
    const specName = session.specialists[specIdx]?.name || '';
    const arr = session.round2[specName] || [];
    if (arr.length >= requested) return true;
    const uf = __STATE.r2Underfill[specIdx];
    return !!(uf && uf.accepted === true);
  }

  // =========================
  // Round-1 Stepper
  // =========================
  async function startRound1Stepper(){
    if (__STATE.r1Locked) { setStatus('Round-1 is locked. Clear Session to run it again.'); return; }
    if (!Array.isArray(session.specialists) || session.specialists.length === 0){
      alert('No specialists available. Run pick first.'); return;
    }
    // Lock sliders as soon as R1 begins
    setSessionSetupLocked(true);

    __STATE.r1Idx = 0;
    setStage('r1', 'startRound1Stepper');
    round1Container.innerHTML = '';
    await generateAndRenderR1ForIndex(__STATE.r1Idx);
  }

  function renderR1Form(specIdx, specName, qArray){
    const letter = String.fromCharCode(65 + specIdx);
    let card = document.getElementById(`r1-s-${specIdx}`);
    const isLast = (specIdx === session.specialists.length - 1);

    if (!card){
      card = document.createElement('div');
      card.className = 'qs-card';
      card.id = `r1-s-${specIdx}`;
      const headerId = `r1-head-${specIdx}`;
      const bodyId = `r1-body-${specIdx}`;

      card.innerHTML = `
        <div class="qs-header" id="${headerId}" role="button" aria-expanded="true" aria-controls="${bodyId}">
          <div class="left">
            <span class="pill" style="min-width:28px; text-align:center;">${letter}</span>
            <div>${escapeHtml(specName)} — Round-1</div>
          </div>
          <div class="right">
            <span class="pill-kpi" id="r1h-${specIdx}">0/${qArray?.length || 0}</span>
            <span class="chev">▾</span>
          </div>
        </div>
        <div class="qs-body" id="${bodyId}">
          <div class="rationale"><span class="muted">Later specialists see earlier specialists’ Q&amp;A to avoid repeats.</span></div>
          <div id="r1-grid-${specIdx}" class="grid-qs"></div>
          <div class="row footer">
            <span class="pill-kpi" id="r1p-${specIdx}">0/${qArray?.length || 0}</span>
            <button class="btn" id="btnR1Next-${specIdx}" ${isLast ? 'style="display:none;"' : ''} disabled>Complete &amp; Next</button>
          </div>
        </div>`;
      round1Container.appendChild(card);
      bindCollapseToggle(card, headerId);
    }

    // Render questions
    const grid = document.getElementById(`r1-grid-${specIdx}`);
    grid.innerHTML = (qArray || []).map((item, qIdx) => {
      const q = escapeHtml(item.q || '');
      const r = escapeHtml(item.rationale || '');
      const taId = `r1a-${specIdx}-${qIdx}`;
      return `
        <div class="qs-card">
          <div class="q">${letter}.${qIdx+1} — ${q}</div>
          <div class="rationale">${r ? `Rationale: ${r}` : ''}</div>
          <textarea id="${taId}" placeholder="Doctor’s answer…">${escapeHtml(item.answer||'')}</textarea>
        </div>`;
    }).join('') || `<div class="placeholder">No questions returned.</div>`;

    // Wire inputs
    (qArray || []).forEach((_, qIdx) => {
      const ta = document.getElementById(`r1a-${specIdx}-${qIdx}`);
      if (!ta) return;
      if (!window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R1) setAnswerValidityClass(ta, (ta.value||'').trim().length>0);
      ta.addEventListener('input', () => {
        const val = (ta.value || '');
        const arr = session.round1[specName];
        if (Array.isArray(arr) && arr[qIdx]) arr[qIdx].answer = val;
        const ok = (val.trim().length > 0) || window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R1;
        if (!window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R1) setAnswerValidityClass(ta, ok);
        updateR1TotalsUI();

        const specComplete = isSpecR1Complete(specName);
        const localNextBtn = document.getElementById(`btnR1Next-${specIdx}`);
        if (!isLast && localNextBtn) {
          const okUnderfill = isR1UnderfillSatisfiedOrAccepted(specIdx, getQCountR1());
          localNextBtn.disabled = !(specComplete && okUnderfill);
        }

        setButtonsState();
        if (isLast && areAllR1ReadyToAdvance() && !genR2Btn.disabled){
          setRound1Lock(true);
          __STATE.r1Idx = null;
          setStage('r2', 'R1 complete');
          setStatus('Round-1 complete — Start Round-2.');
          genR2Btn.scrollIntoView({behavior:'smooth', block:'center'});
        }
        if (!CURRENT_PHASE) applyActiveColumn(computeActiveColumn());
      });
    });

    // Local "Complete & Next" (hidden on last)
    const localNextBtn = document.getElementById(`btnR1Next-${specIdx}`);
    if (localNextBtn){
      localNextBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        const requested = getQCountR1();
        const okUnderfill = isR1UnderfillSatisfiedOrAccepted(specIdx, requested);
        if (!isSpecR1Complete(specName) || !okUnderfill) {
          highlightMissingR1AnswersForSpec(specIdx);
          ensureR1UnderfillBanner(specIdx, specName, requested, (session.round1[specName]||[]).length);
          return;
        }
        collapseCard(document.getElementById(`r1-s-${specIdx}`), true);
        const total = session.specialists.length;
        if (__STATE.r1Idx + 1 < total) {
          __STATE.r1Idx++;
          await generateAndRenderR1ForIndex(__STATE.r1Idx);
        }
      });
    }

    // Update KPIs & UI
    updateR1TotalsUI();
    setButtonsState();
    collapseAllBefore(round1Container, specIdx, 'r1-s-');
    collapseCard(card, false);

    // Underfill banner visibility
    const requested = getQCountR1();
    const received = (session.round1[specName]||[]).length;
    __STATE.r1Underfill[specIdx] = __STATE.r1Underfill[specIdx] || { requested, received, accepted:false };
    __STATE.r1Underfill[specIdx].requested = requested;
    __STATE.r1Underfill[specIdx].received = received;
    if (received >= requested) __STATE.r1Underfill[specIdx].accepted = true;
    ensureR1UnderfillBanner(specIdx, specName, requested, received);
  }

  function isSpecR1Complete(specName){
    const arr = session.round1[specName] || [];
    if (arr.length === 0) return false;
    if (window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R1) return true;
    return arr.every(x => (x?.answer || '').trim().length > 0);
  }
  function highlightMissingR1AnswersForSpec(specIdx) {
    if (window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R1) return;
    const specName = session.specialists[specIdx]?.name || '';
    const arr = session.round1[specName] || [];
    for (let qIdx = 0; qIdx < arr.length; qIdx++) {
      const ta = document.getElementById(`r1a-${specIdx}-${qIdx}`);
      if (!ta) continue;
      const val = (ta.value || '').trim();
      setAnswerValidityClass(ta, val.length > 0);
    }
  }

  // top-up logic (R1)
  async function topUpR1Questions(specIdx, specName, requested){
    const current = session.round1[specName] || [];
    const have = current.length;
    const missing = Math.max(0, requested - have);
    if (missing <= 0) return;

    const priorR1Triples = buildPriorRound1QA(specIdx);
    const priorQuestions = priorR1Triples.map(({ specialist, q }) => ({ specialist, q }));
    // include own existing questions to discourage repeats
    const ownQs = current.map(it => ({ specialist: specName, q: it.q || '' }));
    const mergedPrior = [...priorQuestions, ...ownQs];

    const label = makePhaseLabel('r1-topup', { idx: specIdx+1, total: session.specialists.length, specName });
    setBusy(true, label);
    beginPhase('round1-topup', 'col-round1', label);

    const payload = {
      ctxVersion: window.__CFG.FEATURES.CTX_VERSION,
      role: "round1_questions",
      payload: {
        specialistName: specName,
        languageMode: window.__CFG.LANGUAGE_MODE,
        prompt: window.__CFG.PROMPTS.ROUND1,
        context: {
          intakeText: session.patient_intake,
          specialist: specName,
          numQuestions: missing, // request exactly what's missing
          languageMode: window.__CFG.LANGUAGE_MODE,
          priorQuestions: mergedPrior
        }
      }
    };

    try {
      const data = await withRetry(
        () => callProxyWithTimeout(payload, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
        window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
        (attempt, totalAttempts) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, totalAttempts)
      );
      const newItems = (Array.isArray(data)?data:[])
        .map(item => ({ q: String(item.q||''), rationale: String(item.rationale||''), answer: "" }));
      // merge + dedup
      const merged = dedupQuestionsWithinSpecialist([...current, ...newItems]);
      // trim to requested max
      const finalArr = merged.slice(0, requested);
      // preserve any typed answers by matching normalized q text
      const answerMap = new Map(current.map(it => [normalizeQuestionText(it.q), String(it.answer||'')]));
      finalArr.forEach(it => {
        const key = normalizeQuestionText(it.q);
        if (answerMap.has(key)) it.answer = answerMap.get(key);
      });
      session.round1[specName] = finalArr;
      renderR1Form(specIdx, specName, finalArr);
    } catch (err){
      console.error(err);
      setStatus(`Top-up failed: ${String(err && err.message ? err.message : err)}.`);
    } finally {
      endPhase();
      setBusy(false, '');
      setButtonsState();
    }
  }

  async function generateAndRenderR1ForIndex(idx){
    const specName = session.specialists[idx]?.name || '';
    if (!specName) return;

    const priorR1Triples = buildPriorRound1QA(idx);
    const priorQuestions = priorR1Triples.map(({ specialist, q }) => ({ specialist, q }));

    const label = makePhaseLabel('r1', {
      idx: idx+1,
      total: session.specialists.length,
      specName
    });
    setBusy(true, label);
    beginPhase('round1', 'col-round1', label);

    const requested = getQCountR1();

    const payload = {
      ctxVersion: window.__CFG.FEATURES.CTX_VERSION,
      role: "round1_questions",
      payload: {
        // (removed unused questionsPerSpecialty key to avoid confusion)
        specialistName: specName,
        languageMode: window.__CFG.LANGUAGE_MODE,
        prompt: window.__CFG.PROMPTS.ROUND1,
        context: {
          intakeText: session.patient_intake,
          specialist: specName,
          numQuestions: requested,
          languageMode: window.__CFG.LANGUAGE_MODE,
          priorQuestions: priorQuestions
        }
      }
    };

    try {
      let data = await withRetry(
        () => callProxyWithTimeout(payload, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
        window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
        (attempt, totalAttempts) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, totalAttempts)
      );
      if (!Array.isArray(data)) data = [];
      // enforce count
      let arr = data.map(item => ({ q: String(item.q||''), rationale: String(item.rationale||''), answer: "" }));
      if (arr.length > requested) arr = arr.slice(0, requested);
      if (arr.length < requested){
        // attempt a top-up call for missing questions
        session.round1[specName] = arr;
        await topUpR1Questions(idx, specName, requested);
        return; // topUp function re-renders and updates state
      }
      session.round1[specName] = arr;
      renderR1Form(idx, specName, arr);
      setStatus(`Round-1: ${specName} ready — answer then “Complete & Next”.`);
    } catch (err) {
      console.error(err);
      session.round1[specName] = [];
      renderR1Form(idx, specName, []);
      const grid = document.getElementById(`r1-grid-${idx}`);
      if (grid) grid.innerHTML = `<div class="placeholder">
          <span class="tag-bad">Round-1 unavailable</span> — ${escapeHtml((err && err.message) || 'failed')}.
        </div>`;
      setStatus(`Round-1 failed for ${specName}. You can Clear Session and retry.`);
      __STATE.r1Idx = null;
    } finally {
      endPhase();
      setBusy(false, '');
      setButtonsState();
      if (idx === session.specialists.length - 1 && areAllR1ReadyToAdvance() && !genR2Btn.disabled) {
        genR2Btn.scrollIntoView({behavior:'smooth', block:'center'});
      }
    }
  }

  // =========================
  // Round-2 Stepper
  // =========================
  async function startRound2Stepper(){
    if (!areAllR1ReadyToAdvance()) {
      setStatus('Round-1 incomplete or under-filled — finish/accept Round-1 first.');
      return;
    }
    __STATE.r1Idx = null;
    setRound1Lock(true);
    __STATE.r2Idx = 0;
    setStage('r2', 'startRound2Stepper');
    round2Container.innerHTML = '';
    await generateAndRenderR2ForIndex(__STATE.r2Idx);
  }

  function renderR2Form(specIdx, specName, qArray) {
    const letter = String.fromCharCode(65 + specIdx);
    const isLast = (specIdx === session.specialists.length - 1);

    let card = document.getElementById(`r2-s-${specIdx}`);
    if (!card){
      const headerId = `r2-head-${specIdx}`;
      const bodyId = `r2-body-${specIdx}`;
      card = document.createElement('div');
      card.className = 'qs-card';
      card.id = `r2-s-${specIdx}`;
      card.innerHTML = `
        <div class="qs-header" id="${headerId}" role="button" aria-expanded="true" aria-controls="${bodyId}">
          <div class="left">
            <span class="pill" style="min-width:28px; text-align:center;">${letter}</span>
            <div>${escapeHtml(specName)} — Round-2</div>
          </div>
          <div class="right">
            <span class="pill-kpi" id="r2p-${specIdx}">0/${qArray?.length||0}</span>
            <span class="chev">▾</span>
          </div>
        </div>
        <div class="qs-body" id="${bodyId}">
          <div class="rationale"><span class="muted">Uses all R1 Q&amp;A + prior R2 Q&amp;A. No repeats.</span></div>
          <div id="r2-grid-${specIdx}" class="grid-qs"></div>
          <div class="row footer">
            <button class="btn" id="btnR2Next-${specIdx}" ${isLast ? 'style="display:none;"' : ''} disabled>Complete &amp; Next</button>
          </div>
        </div>`;
      round2Container.appendChild(card);
      bindCollapseToggle(card, headerId);
    }

    const grid = document.getElementById(`r2-grid-${specIdx}`);
    grid.innerHTML = (qArray || []).map((item, qIdx) => {
      const q = escapeHtml(item.q || '');
      const r = escapeHtml(item.rationale || '');
      const taId = `r2a-${specIdx}-${qIdx}`;
      return `
        <div class="qs-card" style="margin-top:10px;">
          <div class="q">${letter}.${qIdx+1} — ${q}</div>
          <div class="rationale">${r ? `Rationale: ${r}` : ''}</div>
          <textarea id="${taId}" placeholder="Doctor’s answer…">${escapeHtml(item.answer||'')}</textarea>
        </div>`;
    }).join('') || `<div class="placeholder">No Round-2 questions returned for ${escapeHtml(specName)}.</div>`;

    (qArray || []).forEach((_, qIdx) => {
      const ta = document.getElementById(`r2a-${specIdx}-${qIdx}`);
      if (!ta) return;
      if (!window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R2) setAnswerValidityClass(ta, (ta.value||'').trim().length>0);
      ta.addEventListener('input', () => {
        const val = (ta.value || '');
        const arr = session.round2[specName];
        if (Array.isArray(arr) && arr[qIdx]) arr[qIdx].answer = val;
        const ok = (val.trim().length > 0) || window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R2;
        if (!window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R2) setAnswerValidityClass(ta, ok);

        updateR2TotalsUI();
        const specComplete = isSpecR2Complete(specName);
        const localNextBtn = document.getElementById(`btnR2Next-${specIdx}`);
        if (!isLast && localNextBtn) {
          const okUnderfill = isR2UnderfillSatisfiedOrAccepted(specIdx, getQCountR2());
          localNextBtn.disabled = !(specComplete && okUnderfill);
        }

        setButtonsState();
        if (isLast && areAllR2ReadyToAdvance() && !genHypAndConBtn.disabled) {
          setStatus('Round-2 complete — Generate Hypotheses & Consensus.');
          genHypAndConBtn.scrollIntoView({behavior:'smooth', block:'center'});
        }

        if (!CURRENT_PHASE) applyActiveColumn(computeActiveColumn());
      });
    });

    const localNextBtn = document.getElementById(`btnR2Next-${specIdx}`);
    if (localNextBtn){
      localNextBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        const requested = getQCountR2();
        const okUnderfill = isR2UnderfillSatisfiedOrAccepted(specIdx, requested);
        if (!isSpecR2Complete(specName) || !okUnderfill) {
          highlightMissingR2AnswersForSpec(specIdx);
          ensureR2UnderfillBanner(specIdx, specName, requested, (session.round2[specName]||[]).length);
          return;
        }
        collapseCard(document.getElementById(`r2-s-${specIdx}`), true);
        const total = session.specialists.length;
        if (__STATE.r2Idx + 1 < total) {
          __STATE.r2Idx++;
          await generateAndRenderR2ForIndex(__STATE.r2Idx);
        }
      });
    }

    updateR2TotalsUI();
    setButtonsState();
    collapseAllBefore(round2Container, specIdx, 'r2-s-');
    collapseCard(card, false);

    const requested = getQCountR2();
    const received = (session.round2[specName]||[]).length;
    __STATE.r2Underfill[specIdx] = __STATE.r2Underfill[specIdx] || { requested, received, accepted:false };
    __STATE.r2Underfill[specIdx].requested = requested;
    __STATE.r2Underfill[specIdx].received = received;
    if (received >= requested) __STATE.r2Underfill[specIdx].accepted = true;
    ensureR2UnderfillBanner(specIdx, specName, requested, received);
  }

  function isSpecR2Complete(specName){
    const arr = session.round2[specName] || [];
    if (arr.length === 0) return false;
    if (window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R2) return true;
    return arr.every(x => (x?.answer||'').trim().length > 0);
  }
  function highlightMissingR2AnswersForSpec(specIdx) {
    if (window.__CFG.RUNTIME.ALLOW_BLANK_ANSWERS_R2) return;
    const specName = session.specialists[specIdx]?.name || '';
    const arr = session.round2[specName] || [];
    for (let qIdx = 0; qIdx < arr.length; qIdx++) {
      const ta = document.getElementById(`r2a-${specIdx}-${qIdx}`);
      if (!ta) continue;
      const val = (ta.value || '').trim();
      setAnswerValidityClass(ta, val.length > 0);
    }
  }

  // top-up logic (R2)
  async function topUpR2Questions(specIdx, specName, requested){
    const current = session.round2[specName] || [];
    const have = current.length;
    const missing = Math.max(0, requested - have);
    if (missing <= 0) return;

    const round1AllBySpecialty = buildAllRound1BySpecialtyExcluding(specName);
    const priorRound2QA = buildPriorRound2QA(specIdx);
    const priorRound2Questions = priorRound2QA.map(({ specialist, q }) => ({ specialist, q }));
    // include own existing R2 questions to discourage repeats
    const ownR2Qs = current.map(it => ({ specialist: specName, q: it.q || '' }));
    const mergedPriorR2 = [...priorRound2Questions, ...ownR2Qs];

    const label = makePhaseLabel('r2-topup', { idx: specIdx+1, total: session.specialists.length, specName });
    setBusy(true, label);
    beginPhase('round2-topup', 'col-round2', label);

    const r1Array = Array.isArray(session.round1[specName]) ? session.round1[specName] : [];
    const r1ForContext = r1Array
      .filter(x => (x?.answer||'').trim().length > 0)
      .map(({ q, rationale, answer }) => ({ q, rationale, answer }));

    const body = {
      ctxVersion: window.__CFG.FEATURES.CTX_VERSION,
      role: "round2_questions",
      payload: {
        prompt: window.__CFG.PROMPTS.ROUND2,
        specialistName: specName,
        languageMode: window.__CFG.LANGUAGE_MODE,
        context: {
          intakeText: session.patient_intake,
          specialistName: specName,
          questionsPerSpecialty: missing, // request exactly what's missing
          languageMode: window.__CFG.LANGUAGE_MODE,

          round1QA: r1ForContext,
          priorRound2Questions: mergedPriorR2,
          round1AllBySpecialty: round1AllBySpecialty
        }
      }
    };

    try {
      const data = await withRetry(
        () => callProxyWithTimeout(body, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
        window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
        (attempt, totalAttempts) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, totalAttempts)
      );
      const newItems = (Array.isArray(data)?data:[])
        .map(item => ({ q: String(item.q || ''), rationale: String(item.rationale || ''), answer: "" }));
      const merged = dedupQuestionsWithinSpecialist([...current, ...newItems]);
      const finalArr = merged.slice(0, requested);
      // preserve typed answers
      const answerMap = new Map(current.map(it => [normalizeQuestionText(it.q), String(it.answer||'')]));
      finalArr.forEach(it => {
        const key = normalizeQuestionText(it.q);
        if (answerMap.has(key)) it.answer = answerMap.get(key);
      });
      session.round2[specName] = finalArr;
      renderR2Form(specIdx, specName, finalArr);
    } catch (err){
      console.error(err);
      setStatus(`Top-up failed: ${String(err && err.message ? err.message : err)}.`);
    } finally {
      endPhase();
      setBusy(false, '');
      setButtonsState();
    }
  }

  async function generateAndRenderR2ForIndex(idx){
    const specName = session.specialists[idx]?.name || '';
    if (!specName) return;

    const round1AllBySpecialty = buildAllRound1BySpecialtyExcluding(specName);
    const priorRound2QA = buildPriorRound2QA(idx);
    const priorRound2Questions = priorRound2QA.map(({ specialist, q }) => ({ specialist, q }));

    const label = makePhaseLabel('r2', { idx: idx+1, total: session.specialists.length, specName });
    setBusy(true, label);
    beginPhase('round2', 'col-round2', label);

    const requested = getQCountR2();

    const r1Array = Array.isArray(session.round1[specName]) ? session.round1[specName] : [];
    const r1ForContext = r1Array
      .filter(x => (x?.answer||'').trim().length > 0)
      .map(({ q, rationale, answer }) => ({ q, rationale, answer }));

    const body = {
      ctxVersion: window.__CFG.FEATURES.CTX_VERSION,
      role: "round2_questions",
      payload: {
        prompt: window.__CFG.PROMPTS.ROUND2,
        specialistName: specName,
        languageMode: window.__CFG.LANGUAGE_MODE,
        context: {
          intakeText: session.patient_intake,
          specialistName: specName,
          questionsPerSpecialty: requested,
          languageMode: window.__CFG.LANGUAGE_MODE,

          round1QA: r1ForContext,
          priorRound2Questions: priorRound2Questions,
          round1AllBySpecialty: round1AllBySpecialty
        }
      }
    };

    try {
      let data = await withRetry(
        () => callProxyWithTimeout(body, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
        window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
        (attempt, totalAttempts) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, totalAttempts)
      );
      if (!Array.isArray(data)) data = [];
      let arr = data.map(item => ({ q: String(item.q || ''), rationale: String(item.rationale || ''), answer: "" }));
      if (arr.length > requested) arr = arr.slice(0, requested);
      if (arr.length < requested){
        session.round2[specName] = arr;
        await topUpR2Questions(idx, specName, requested);
        return; // re-render happens in top-up
      }
      session.round2[specName] = arr;
      renderR2Form(idx, specName, session.round2[specName]);
      setStatus(`Round-2: ${specName} ready — answer then “Complete & Next”.`);
    } catch (errSpec) {
      console.error(errSpec);
      session.round2[specName] = [];
      renderR2Form(idx, specName, []);
      const grid = document.getElementById(`r2-grid-${idx}`);
      if (grid) grid.innerHTML = `<div class="placeholder">
          <span class="tag-bad">Round-2 unavailable</span> — ${escapeHtml((errSpec && errSpec.message) || 'failed')}.
        </div>`;
      setStatus(`Round-2 failed for ${specName}. You can Clear Session and retry.`);
      __STATE.r2Idx = null;
    } finally {
      endPhase();
      setBusy(false, '');
      setButtonsState();
      if (idx === session.specialists.length - 1 && areAllR2ReadyToAdvance() && !genHypAndConBtn.disabled) {
        genHypAndConBtn.scrollIntoView({behavior:'smooth', block:'center'});
      }
    }
  }

  // ---------- Hypotheses rendering & progress ----------
  function updateHypProgressUI() {
    const total = session.specialists.length || 0;
    let processed = 0;
    if (hypContainer) {
      const cards = hypContainer.querySelectorAll('[id^="hyp-s-"]');
      cards.forEach(el => {
        const st = el.getAttribute('data-state');
        if (st === 'done' || st === 'unavailable') processed++;
      });
    }
    if (hypKpiEl) hypKpiEl.textContent = `${processed}/${total}`;
  }
  function renderHypothesisPending(specIdx, specName) {
    const card = ensureHypCard(specIdx, specName, `<div class="placeholder">Generating diagnostic hypothesis…</div>`);
    if (card) card.setAttribute('data-state','pending');
    updateHypProgressUI();
  }
  function renderHypothesisUnavailable(specIdx, specName, reasonText) {
    const card = ensureHypCard(specIdx, specName, `<div class="placeholder"><span class="tag-bad">Unavailable</span> — ${escapeHtml(reasonText || '2 attempts failed')}</div>`);
    if (card) card.setAttribute('data-state','unavailable');
    updateHypProgressUI();
  }
  function renderHypothesis(specIdx, specName, obj) {
    const body = `
      <div class="q">Diagnosis</div>
      <div class="rationale">${escapeHtml(obj.diagnosis || '')}</div>
      <div class="q" style="margin-top:8px;">Justification</div>
      <div class="rationale prewrap">${escapeHtml(obj.justification || '')}</div>
      <div class="q" style="margin-top:8px;">Steelman against</div>
      <div class="rationale prewrap">${escapeHtml(obj.steelman || '')}</div>`;
    const card = ensureHypCard(specIdx, specName, body);
    if (card) card.setAttribute('data-state','done');
    updateHypProgressUI();
  }
  function ensureHypCard(specIdx, specName, innerHtml) {
    let card = document.getElementById(`hyp-s-${specIdx}`);
    if (!card) {
      card = document.createElement('div');
      card.className = 'qs-card';
      card.id = `hyp-s-${specIdx}`;
      hypContainer.appendChild(card);
    }
    const letter = String.fromCharCode(65 + specIdx);
    card.innerHTML = `<div class="q">${letter}. ${escapeHtml(specName)} — Hypothesis</div>${innerHtml}`;
    return card;
  }

  // ---------- Session Setup slider wiring ----------
  function refreshSessionSetupUI(){
    if (outSpecs) outSpecs.textContent = String(getNumSpecialists());
    if (outQs) outQs.textContent = String(getQCountR1());
    if (specKpiEl) specKpiEl.textContent = `${(session.specialists||[]).length || 0}/${getNumSpecialists()}`;
    if (sessionSetupSummaryEl) sessionSetupSummaryEl.textContent = `Current: ${getNumSpecialists()} specialists × ${getQCountR1()} questions/each.`;
    updateSpecUnderfillBanner();
  }
  function setSessionSetupLocked(locked){
    if (sliderSpecs) { sliderSpecs.disabled = !!locked; sliderSpecs.title = locked ? 'Locked while session is active — Clear Session to adjust.' : ''; }
    if (sliderQs)    { sliderQs.disabled = !!locked;    sliderQs.title    = locked ? 'Locked while session is active — Clear Session to adjust.' : ''; }
    const noteEl = document.getElementById('sessionSetupNote');
    if (noteEl) noteEl.textContent = locked ? 'Locked — Clear Session to adjust.' : 'You can change these until Round-1 starts.';
  }
  function initSessionSetupFromConfig(){
    if (sliderSpecs) sliderSpecs.value = String(clampInt(window.__CFG.COUNTS.NUM_SPECIALISTS,1,10));
    if (sliderQs)    sliderQs.value    = String(clampInt(window.__CFG.COUNTS.QUESTIONS_PER_SPECIALTY_ROUND1,1,10));
    __LIVE.numSpecialists = clampInt(sliderSpecs ? sliderSpecs.value : window.__CFG.COUNTS.NUM_SPECIALISTS, 1, 10);
    __LIVE.questionsPerSpecialist = clampInt(sliderQs ? sliderQs.value : window.__CFG.COUNTS.QUESTIONS_PER_SPECIALTY_ROUND1, 1, 10);
    refreshSessionSetupUI();
  }
  if (sliderSpecs) sliderSpecs.addEventListener('input', () => {
    if (sliderSpecs.disabled) return;
    __LIVE.numSpecialists = clampInt(sliderSpecs.value, 1, 10);
    refreshSessionSetupUI();
    if (Array.isArray(session.specialists) && session.specialists.length) renderSpecSummary(session.specialists);
    setButtonsState();
  });
  if (sliderQs) sliderQs.addEventListener('input', () => {
    if (sliderQs.disabled) return;
    __LIVE.questionsPerSpecialist = clampInt(sliderQs.value, 1, 10);
    refreshSessionSetupUI();
    setButtonsState();
  });

  // ---------- Clear Session ----------
  clearBtn.addEventListener('click', (e) => {
    e.preventDefault();
    if (window.__CFG.UI.CONFIRM_ON_CLEAR) {
      const ok = confirm("Clear the current session? This cannot be undone.");
      if (!ok) return;
    }
    session = makeEmptySession();
    setRound1Lock(false);
    __STATE.hypothesesRan = false;
    __STATE.r1Idx = null;
    __STATE.r2Idx = null;
    __STATE.r1Underfill = {};
    __STATE.r2Underfill = {};

    intakeEl.value = "";
    round1Container.innerHTML = '<div class="placeholder">Pick specialists, then start Round-1. You will complete A→B→C… sequentially.</div>';
    round2Container.innerHTML = '<div class="placeholder">Complete Round-1 first, then start Round-2 (A→B→C…).</div>';
    hypContainer.innerHTML = '<div class="placeholder">Generate Round-2 before you can generate Hypotheses and Consensus.</div>';
    consensusNoteEl.textContent = '[Consensus note will render here]';
    r1KpiEl.textContent = '0/0';
    if (hypKpiEl) hypKpiEl.textContent = '0/0';
    if (r1StepperKpiEl) r1StepperKpiEl.textContent = '0/0 specialists';
    if (r2StepperKpiEl) r2StepperKpiEl.textContent = '0/0 specialists';

    setStatus('Ready • Session cleared');

    genR2Btn.disabled = true;
    genHypAndConBtn.disabled = true;
    copyBtn.disabled = true;
    pickAndStartR1Btn.disabled = true;
    clearBtn.disabled = true;

    // Re-enable sliders after clearing
    setSessionSetupLocked(false);
    refreshSessionSetupUI();
    hideSpecUnderfillBanner();

    endPhase();
    setStage('intake', 'clear');
    applyActiveColumn('col-intake');
  });

  // ---------- Pick Specialists ----------
  function updateSpecUnderfillBanner(){
    const requested = getNumSpecialists();
    const received = session.specialists.length;
    if (!specUnderfillBanner) return;
    if (received > 0 && received < requested){
      specUnderfillMsg.textContent = `Requested ${requested} specialists, received ${received}.`;
      specUnderfillBanner.classList.remove('hidden');
    } else {
      specUnderfillBanner.classList.add('hidden');
    }
  }
  function hideSpecUnderfillBanner(){
    if (specUnderfillBanner) specUnderfillBanner.classList.add('hidden');
  }

  async function runPickSpecialistsFlow(){
    if (__STATE.r1Locked) { setStatus('Round-1 is locked. Clear Session to pick again.'); return; }
    const intake = (intakeEl.value || '').trim();
    if (!intake){ setStatus('Please paste the patient story first.'); return; }

    if (!window.__CFG.PROMPTS.PICK_SPECIALISTS || !window.__CFG.PROMPTS.PICK_SPECIALISTS.trim()){
      alert('Paste your PICK_SPECIALISTS prompt into CFG.PROMPTS.PICK_SPECIALISTS.'); return;
    }

    const label = makePhaseLabel('pick');
    setBusy(true, label);
    beginPhase('pick', 'col-intake', label);

    const requested = getNumSpecialists();

    const body = {
      ctxVersion: window.__CFG.FEATURES.CTX_VERSION,
      role: "pick_specialists",
      payload: {
        prompt: window.__CFG.PROMPTS.PICK_SPECIALISTS,
        context: {
          intakeText: intake,
          numSpecialists: requested,
          languageMode: window.__CFG.LANGUAGE_MODE
        }
      }
    };

    try {
      let data = await withRetry(
        () => callProxyWithTimeout(body, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
        window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
        (attempt, total) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, total)
      );

      if (!Array.isArray(data)) data = [];
      // first pass
      let picks = dedupSpecialistsByName(data);
      // hard trim to requested if too many
      if (picks.length > requested) picks = picks.slice(0, requested);

      // if under-filled, try one top-up attempt
      if (picks.length < requested){
        const label2 = makePhaseLabel('pick-topup');
        beginPhase('pick', 'col-intake', label2);
        const data2 = await withRetry(
          () => callProxyWithTimeout(body, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
          window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
          (attempt, total) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, total)
        );
        const more = dedupSpecialistsByName(Array.isArray(data2)?data2:[]);
        // merge + dedup
        const merged = dedupSpecialistsByName([...picks, ...more]);
        picks = merged.slice(0, requested);
      }

      session.patient_intake = intake;
      session.specialists = picks;
      renderSpecSummary(session.specialists);
      setStatus(`Picked ${session.specialists.length}/${requested} specialists.`);
      clearBtn.disabled = false;
    } catch (err) {
      setStatus(`Pick specialists failed: ${String(err && err.message ? err.message : err)}. You can try again.`);
      console.error(err);
      throw err;
    } finally {
      endPhase();
      setBusy(false, '');
      setButtonsState();
    }
  }

  // Underfill banner actions for specialists
  if (btnSpecRetry) btnSpecRetry.addEventListener('click', async (e) => {
    e.preventDefault();
    await runPickSpecialistsFlow();
  });
  if (btnSpecAccept) btnSpecAccept.addEventListener('click', (e) => {
    e.preventDefault();
    const received = session.specialists.length;
    if (received <= 0) return;
    // Lower the slider to match what we have = explicit acceptance
    __LIVE.numSpecialists = clampInt(received, 1, 10);
    if (sliderSpecs) sliderSpecs.value = String(__LIVE.numSpecialists);
    refreshSessionSetupUI();
    hideSpecUnderfillBanner();
    setButtonsState();
  });

  // ---------- R1/R2/Hyp+Consensus flows ----------
  pickAndStartR1Btn.addEventListener('click', async (e) => {
    e.preventDefault();
    try {
      await runPickSpecialistsFlow();
      if (session.specialists.length > 0 && !hasPickUnderfill()) {
        await startRound1Stepper();
      }
    } catch (_) {}
  });

  genR2Btn.addEventListener('click', async (e) => {
    e.preventDefault();
    if (genR2Btn.disabled) return;
    await startRound2Stepper();
  });

  genHypAndConBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    try {
      await runHypothesesFlow();
      await runConsensusFlow();
    } catch (_) {}
  });

  // ---------- Hypotheses & Consensus ----------
  async function runHypothesesFlow(){
    if (genHypAndConBtn && genHypAndConBtn.disabled) {
      setStatus('Round-2 answers incomplete or under-filled — complete/accept all first.');
      return;
    }
    if (!window.__CFG.PROMPTS.DIAGNOSTIC_HYPOTHESIS || !window.__CFG.PROMPTS.DIAGNOSTIC_HYPOTHESIS.trim()) {
      alert('Paste DIAGNOSTIC_HYPOTHESIS prompt into CFG.PROMPTS.DIAGNOSTIC_HYPOTHESIS.');
      throw new Error('Missing DIAGNOSTIC_HYPOTHESIS prompt');
    }

    hypContainer.innerHTML = '';
    __STATE.hypothesesRan = false;
    session.hypotheses = {};

    setStage('hypcons', 'runHypothesesFlow');

    try {
      const total = session.specialists.length;
      for (let idx = 0; idx < total; idx++) {
        const specName = session.specialists[idx]?.name || '';
        if (!specName) continue;

        renderHypothesisPending(idx, specName);

        const r1Array = Array.isArray(session.round1[specName]) ? session.round1[specName] : [];
        const r2Array = Array.isArray(session.round2[specName]) ? session.round2[specName] : [];

        const r1MapsExclSelf = buildAllRound1BySpecialtyExcluding(specName);
        const r2MapsExclSelf = buildAllRound2BySpecialtyExcluding(specName);

        const body = {
          ctxVersion: window.__CFG.FEATURES.CTX_VERSION,
          role: "diagnostic_hypothesis",
          payload: {
            prompt: window.__CFG.PROMPTS.DIAGNOSTIC_HYPOTHESIS,
            context: {
              intakeText: session.patient_intake,
              specialistName: specName,
              languageMode: window.__CFG.LANGUAGE_MODE,

              round1QA: r1Array.map(({ q, rationale, answer }) => ({ q, rationale, answer })),
              round2QA: r2Array.map(({ q, rationale, answer }) => ({ q, rationale, answer })),

              allRound1BySpecialty: r1MapsExclSelf,
              allRound2BySpecialty: r2MapsExclSelf
            }
          }
        };

        const label = makePhaseLabel('hyp', { idx: idx+1, total, specName });
        setBusy(true, label);
        beginPhase('hypothesis', 'col-hypcons', label);

        try {
          const data = await withRetry(
            () => callProxyWithTimeout(body, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
            window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
            (attempt, totalAttempts) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, totalAttempts)
          );
          if (!data || typeof data !== "object") throw new Error('Empty/invalid hypothesis object.');
          const { diagnosis, justification, steelman } = data;
          if (typeof diagnosis !== 'string' || typeof justification !== 'string' || typeof steelman !== 'string') {
            throw new Error('Expected { diagnosis, justification, steelman } as strings.');
          }
          session.hypotheses[specName] = { diagnosis, justification, steelman };
          renderHypothesis(idx, specName, session.hypotheses[specName]);
          setStatus(`Hypothesis: ${specName} completed.`);
        } catch (errSpec) {
          console.error(errSpec);
          renderHypothesisUnavailable(idx, specName, (errSpec && errSpec.message) || 'failed');
          setStatus(`Hypothesis: ${specName} failed after retry. Continuing…`);
        } finally {
          endPhase();
          setBusy(false, '');
          setButtonsState();
        }
      }

      __STATE.hypothesesRan = true;
      setStatus('Hypotheses complete. Generating consensus…');
    } catch {
      // no-op
    }
  }

  async function runConsensusFlow(){
    if (!__STATE.hypothesesRan) {
      alert('Please generate Hypotheses first.');
      throw new Error('Hypotheses not yet run');
    }
    if (!window.__CFG.PROMPTS.CONSENSUS || !window.__CFG.PROMPTS.CONSENSUS.trim()) {
      alert('Paste CONSENSUS prompt into CFG.PROMPTS.CONSENSUS before running.');
      throw new Error('Missing CONSENSUS prompt');
    }

    setStage('hypcons', 'runConsensusFlow');
    const label = makePhaseLabel('consensus');
    setBusy(true, label);
    beginPhase('consensus', 'col-hypcons', label);

    function stringToBulletsArray(s) {
      return String(s || '')
        .split('\n')
        .map(line => line.trim().replace(/^-+\s*/, ''))
        .filter(Boolean);
    }

    const ctxHypotheses = {};
    for (const spec of session.specialists) {
      const name = spec?.name || '';
      if (!name) continue;
      if (session.hypotheses[name]) {
        const h = session.hypotheses[name];
        ctxHypotheses[name] = {
          diagnosis: String(h.diagnosis || ''),
          justification: stringToBulletsArray(h.justification),
          steelman: stringToBulletsArray(h.steelman)
        };
      }
    }

    const body = {
      ctxVersion: window.__CFG.FEATURES.CTX_VERSION,
      role: "consensus",
      payload: {
        prompt: window.__CFG.PROMPTS.CONSENSUS,
        context: {
          intakeText: session.patient_intake,
          specialists: session.specialists,
          round1: buildAllRound1BySpecialty(),
          round2: buildAllRound2BySpecialty(),
          hypotheses: ctxHypotheses,
          languageMode: window.__CFG.LANGUAGE_MODE
        }
      }
    };

    try {
      const data = await withRetry(
        () => callProxyWithTimeout(body, window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS),
        window.__CFG.RUNTIME.RETRY_ONCE ? 1 : 0,
        (attempt, totalAttempts) => resetOverlayAttempt(window.__CFG.RUNTIME.PER_CALL_TIMEOUT_MS, attempt, totalAttempts)
      );

      const note = (data && typeof data.noteText === 'string') ? data.noteText : '';
      if (!note.trim()) throw new Error('Consensus returned empty text. Adjust prompt or retry.');
      session.consensus.noteText = note;
      consensusNoteEl.textContent = note;
      copyBtn.disabled = false;
      setStatus('Consensus ready. You can copy the note.');
    } catch (err) {
      console.error(err);
      setStatus(`Consensus failed: ${String(err && err.message ? err.message : err)}. You can try again.`);
      throw err;
    } finally {
      setBusy(false, '');
      endPhase();
      setButtonsState();
    }
  }

  // ---------- Copy note ----------
  copyBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    const text = session.consensus && session.consensus.noteText ? session.consensus.noteText : '';
    if (!text.trim()) return;
    try {
      await navigator.clipboard.writeText(text);
      setStatus('Consensus copied to clipboard.');
    } catch {
      const sel = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(consensusNoteEl);
      sel.removeAllRanges(); sel.addRange(range);
      document.execCommand('copy');
      sel.removeAllRanges();
      setStatus('Consensus copied to clipboard (fallback).');
    }
  });

  // ---------- Tutorial modal helpers (NEW) ----------
  const _modalRootEls = [document.querySelector('main.container'), document.querySelector('header.topbar')];
  let _tutorialPrevFocus = null;

  function _setInert(on){
    _modalRootEls.forEach(el=>{
      if(!el) return;
      if ('inert' in el) { el.inert = !!on; }
      el.setAttribute('aria-hidden', on ? 'true' : 'false');
      if (on) { el.style.pointerEvents = 'none'; }
      else { el.style.pointerEvents = ''; }
    });
  }
  function _focusFirst(el){
    const f = el.querySelectorAll('button, [href], input, textarea, select, [tabindex]:not([tabindex="-1"])');
    if (f.length) f[0].focus();
  }
  function openTutorial(){
    if (!tutorialBackdrop || !tutorialModal) return;
    _tutorialPrevFocus = document.activeElement;
    document.body.classList.add('modal-open');
    tutorialBackdrop.classList.remove('hidden');
    tutorialBackdrop.removeAttribute('aria-hidden');
    __STATE.tutorialOpen = true;
    _setInert(true);
    _focusFirst(tutorialModal);
  }
  function closeTutorial(markSeen){
    if (!tutorialBackdrop || !tutorialModal) return;
    document.body.classList.remove('modal-open');
    tutorialBackdrop.classList.add('hidden');
    tutorialBackdrop.setAttribute('aria-hidden','true');
    __STATE.tutorialOpen = false;
    _setInert(false);
    if (markSeen) {
      try { localStorage.setItem(TUTORIAL_SEEN_KEY,'1'); } catch(_) {}
    }
    // return focus to header button for good keyboard flow
    if (btnTutorial) btnTutorial.focus();
    else if (_tutorialPrevFocus && _tutorialPrevFocus.focus) _tutorialPrevFocus.focus();
  }

  // Global key handling for ESC + focus trap
  document.addEventListener('keydown', (e)=>{
    if (!__STATE.tutorialOpen) return;
    if (e.key === 'Escape'){
      e.preventDefault();
      closeTutorial(true);
      return;
    }
    if (e.key === 'Tab'){
      const f = tutorialModal.querySelectorAll('button, [href], input, textarea, select, [tabindex]:not([tabindex="-1"])');
      if (!f.length) return;
      const first = f[0], last = f[f.length-1];
      if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
      else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
    }
  });

  if (btnTutorial) btnTutorial.addEventListener('click', (e)=>{ e.preventDefault(); openTutorial(); });
  if (tutorialOk) tutorialOk.addEventListener('click', ()=> closeTutorial(true));

  // ---------- Initial state ----------
  const __CFG = window.__CFG;
  setRound1Lock(false);

  pickAndStartR1Btn.disabled  = true;
  clearBtn.disabled = true;
  genR2Btn.disabled = true;
  genHypAndConBtn.disabled= true;
  copyBtn.disabled  = true;

  r1KpiEl.textContent = '0/0';
  if (hypKpiEl) hypKpiEl.textContent = '0/0';
  if (r1StepperKpiEl) r1StepperKpiEl.textContent = '0/0 specialists';
  if (r2StepperKpiEl) r2StepperKpiEl.textContent = '0/0 specialists';
  setStatus('Ready • Waiting for intake');

  round1Container.innerHTML = '<div class="placeholder">Pick specialists, then start Round-1. You will complete A→B→C… sequentially.</div>';
  round2Container.innerHTML = '<div class="placeholder">Complete Round-1 first, then start Round-2 (A→B→C…).</div>';
  hypContainer.innerHTML    = '<div class="placeholder">Generate Round-2 before you can generate Hypotheses and Consensus.</div>';

  // init sliders from config defaults; unlocked initially
  initSessionSetupFromConfig();
  setSessionSetupLocked(false);

  setStage('intake', 'init');
  applyActiveColumn('col-intake');

  // Auto-show tutorial only if not seen before (versioned key)
  try {
    if (!localStorage.getItem(TUTORIAL_SEEN_KEY)) {
      openTutorial();
    }
  } catch(_) { /* if storage blocked, just open */ openTutorial(); }
  </script>

  

</body>
</html>
